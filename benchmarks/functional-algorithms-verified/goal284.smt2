; TODO try replacing this with int
(declare-datatype nat ((zero) (s (s_0 nat))))
(declare-datatype treeh (par (a) ((LeafH (LeafH_0 nat) (LeafH_1 a)) (NodeH (NodeH_0 nat) (NodeH_1 (treeh a)) (NodeH_2 (treeh a))))))
(declare-fun plus (nat nat) nat)
(assert (forall ((x nat)) (= (plus zero x) x)))
(assert (forall ((x nat) (y nat)) (= (plus (s x) y) (s (plus x y)))))
(declare-fun in_alphabet (par (a) (a (treeh a)) Bool))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (in_alphabet a x (LeafH a w y)) (= x y)))))
(assert (par (a) (forall ((w nat) (x a) (t1 (treeh a)) (t2 (treeh a))) (= (in_alphabet a x (NodeH a w t1 t2))
  (or (in_alphabet a x t1) (in_alphabet a x t2))))))
(declare-fun consistent (par (a) ((treeh a)) Bool))
(assert (par (a) (forall ((w nat) (x a)) (consistent a (LeafH a w x)))))
; TODO the distinct here is not appropriate for empty intersection
;(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (consistent a (NodeH a w t1 t2))
;  (and (forall ((x a)) (distinct (in_alphabet a x t1) (in_alphabet a x t2))) (consistent a t1) (consistent a t2))))))
(declare-fun freq (par (a) ((treeh a) a) nat))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (freq a (LeafH a w x) y) (ite (= x y) w zero)))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a)) (x a)) (= (freq a (NodeH a w t1 t2) x)
  (plus (freq a t1 x) (freq a t2 x))))))
(declare-fun weight (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (weight a (LeafH a w x)) w))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (weight a (NodeH a w t1 t2))
  (plus (weight a t1) (weight a t2))))))
(declare-fun cost (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (cost a (LeafH a w x)) zero))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (cost a (NodeH a w t1 t2))
  (plus (plus (weight a t1) (cost a t1)) (plus (weight a t2) (cost a t2)))))))
; TODO define this
(declare-fun sibling (par (a) ((treeh a) a) a))
(declare-fun mergeSibling (par (a) ((treeh a) a) (treeh a)))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (mergeSibling a (LeafH a w x) y) (LeafH a w x)))))
(assert (par (a) (forall ((w nat) (wx nat) (x a) (wy nat) (y a) (z a)) (= (mergeSibling a (NodeH a w (LeafH a wx x) (LeafH a wy y)) z)
  (ite (or (= z x) (= z y)) (LeafH a (plus wx wy) z) (NodeH a w (LeafH a wx x) (LeafH a wy y)))))))
(assert (par (a) (forall ((w nat) (v nat) (va (treeh a)) (vb (treeh a)) (t2 (treeh a)) (x a))
  (= (mergeSibling a (NodeH a w (NodeH a v va vb) t2) x) (NodeH a w (mergeSibling a (NodeH a v va vb) x) (mergeSibling a t2 x))))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (v nat) (va (treeh a)) (vb (treeh a)) (x a))
  (= (mergeSibling a (NodeH a w t1 (NodeH a v va vb)) x) (NodeH a w (mergeSibling a t1 x) (mergeSibling a (NodeH a v va vb) x))))))

; consistent(t) & sibling(t,a) != a -> cost(mergeSibling(t,a)) + freq(t,a) + freq(t,sibling(t,a)) = cost(t)
(assert-not (par (a) (forall ((t (treeh a)) (x a)) (=> (and (consistent a t) (distinct (sibling a t x) x))
  (= (plus (plus (cost a (mergeSibling a t x)) (freq a t x)) (freq a t (sibling a t x))) (cost a t))))))
