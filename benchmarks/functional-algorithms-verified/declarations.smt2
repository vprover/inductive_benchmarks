;(declare-datatype nat ((zero) (s (s_0 nat))))
(declare-datatype list ((Nil) (Cons (Cons_0 Int) (Cons_1 list))))
(declare-datatype bool_list ((BNil) (BCons (BCons_0 Bool) (BCons_1 bool_list))))
(declare-datatype lists ((Nils) (Conss (Conss_0 list) (Conss_1 lists))))
(declare-datatype option ((None) (Some (Some_0 Int))))
(declare-datatype tree ((Leaf) (Node (Node_0 tree) (Node_1 Int) (Node_2 tree))))
(declare-datatype itree ((ILeaf) (INode (INode_0 itree) (INode_1 Int) (INode_2 Int) (INode_3 itree))))
(declare-datatype cmp_val ((LT) (EQ) (GT)))
(declare-datatype tree23 ((Leaf23) (Node2 (Node2_0 tree23) (Node2_1 Int) (Node2_2 tree23)) (Node3 (Node3_0 tree23) (Node3_1 Int) (Node3_2 tree23) (Node3_3 Int) (Node3_4 tree23))))
(declare-datatype upI ((TI (TI_0 tree23)) (OF (OF_0 tree23) (OF_1 Int) (OF_2 tree23))))
(declare-datatype upD ((TD (TD_0 tree23)) (UF (UF_0 tree23))))
(declare-datatype tree23s ((T (T_0 tree23)) (TTs (TTs_0 tree23) (TTs_1 Int) (TTs_2 tree23))))
(declare-datatype color ((Red) (Black)))
(declare-datatype bal ((Lh) (Bal) (Rh)))
;(declare-datatype tree4 ((Leaf4) (Lh (Lh_0 tree4) (Lh_1 Int) (Lh_2 tree4)) (Bal (Bal_0 tree4) (Bal_1 Int) (Bal_2 tree4)) (Rh (Rh_0 tree4) (Rh_1 Int) (Rh_2 tree4))))
;(declare-datatype trie ((Nd Bool ('a -> 'a trie option))))
(declare-datatype trie ((Lf) (Nd (Nd_0 Bool) (Nd_1 trie) (Nd_2 trie))))
(declare-datatype trieP ((LfP) (NdP (NdP_0 bool_list) (NdP_1 Bool) (NdP_2 trieP) (NdP_3 trieP))))

; pairs -- delete these once a polymorphic tuple can be used instead
(declare-datatype int_tree_pair ((itp (itp_0 Int) (itp_1 tree))))
(declare-datatype tree_list_pair ((tlp (tlp_0 tree) (tlp_1 list))))

(declare-fun append (list list) list)
(declare-fun rev (list) list)
(declare-fun itrev (list list) list)
(declare-fun sorted (list) Bool)
(declare-fun insort (Int list) list)
(declare-fun isort (list) list)
(declare-fun T_insort (Int list) Int)
(declare-fun T_isort (list) Int)
(declare-fun quicksort (list) list)
(declare-fun quicksort2 (list list) list)
;(declare-fun partition3 (Int list) tuple(list,list,list))
(declare-fun quicksort3 (list) list)
(declare-fun T_quicksort (list) Int)
(declare-fun merge (list list) list)
(declare-fun msort (list) list)
(declare-fun C_merge (list list) Int)
(declare-fun C_msort (list) Int)
(declare-fun len_list (list) Int)
(declare-fun msort2 (list) list)
(declare-fun merge_adj (lists) lists)
(declare-fun merge_all (lists) list)
(declare-fun msort_bu (list) list)
(declare-fun C_merge_adj (lists) Int)
(declare-fun C_merge_all (lists) Int)
(declare-fun C_msort_bu (list) Int)
(declare-fun even (Int) Bool)
(declare-fun odd (Int) Bool)
(declare-fun runs (list) lists)
;(declare-fun asc (Int (=> list list) list) lists)
(declare-fun desc (Int list list) lists)
(declare-fun nmsort (list) list)
;(declare-fun Ball (Int (=> Int Bool)) Bool)
(declare-fun C_runs (list) Int)
;(declare-fun C_asc (Int (=> list list) list) Int)
(declare-fun C_desc (Int list list) Int)
(declare-fun C_nmsort (list) Int)
(declare-fun concat (lists) list)
(declare-fun lg (Int) Real)
(declare-fun ceil (Real) Int)
(declare-fun floor (Real) Int)
;(declare-fun filter ((=> Int Int) list) list)
;(declare-fun sort_key ((=> Int Int) list) list)
;(declare-fun insort_key ((=> Int Int) Int list) list)
;(declare-fun isort_key ((=> Int Int) list) list)
; already declared
;(declare-fun select (Int list) Int)
(declare-fun minus (Int Int) Int)
(declare-fun take (Int list) list)
(declare-fun drop (Int list) list)
(declare-fun select0 (list) Int)
(declare-fun select1 (list) Int)
; already declared
;(declare-fun distinct (list) Bool)
(declare-fun median (list) Int)
(declare-fun chop (Int list) lists)
(declare-fun min (Int Int) Int)
(declare-fun max (Int Int) Int)

(declare-fun in_set_tree (Int tree) Bool)
(assert (forall ((x Int)) (not (in_set_tree x Leaf))))
(assert (forall ((x Int) (l tree) (a Int) (r tree)) (= (in_set_tree x (Node l a r)) (or (= x a) (in_set_tree x l) (in_set_tree x r)))))

(declare-fun inorder (tree) list)
(assert (= (inorder Leaf) Nil))
(assert (forall ((l tree) (d Int) (r tree)) (= (inorder (Node l d r)) (append (inorder l) (append (Cons d Nil) (inorder r))))))
(declare-fun preorder (tree) list)
(assert (= (preorder Leaf) Nil))
(assert (forall ((l tree) (d Int) (r tree)) (= (preorder (Node l d r)) (Cons d (append (inorder l) (inorder r))))))
(declare-fun size (tree) Int)
(assert (= (size Leaf) 0))
(assert (forall ((l tree) (d Int) (r tree)) (= (size (Node l d r)) (+ (size l) (size r) 1))))
(declare-fun size1 (tree) Int)
(assert (= (size1 Leaf) 1))
(assert (forall ((l tree) (d Int) (r tree)) (= (size1 (Node l d r)) (+ (size l) (size r)))))
(declare-fun h (tree) Int)
(assert (= (h Leaf) 0))
(assert (forall ((l tree) (d Int) (r tree)) (= (h (Node l d r)) (+ (max (h l) (h r)) 1))))
(declare-fun mh (tree) Int)
(assert (= (mh Leaf) 0))
(assert (forall ((l tree) (d Int) (r tree)) (= (mh (Node l d r)) (+ (min (mh l) (mh r)) 1))))
(declare-fun complete (tree) Bool)
(assert (complete Leaf))
(assert (forall ((l tree) (d Int) (r tree)) (= (complete (Node l d r)) (and (= (h l) (h r)) (complete l) (complete r)))))
(declare-fun acomplete (tree) Bool)
(assert (forall ((t tree)) (= (acomplete t) (<= (- (h t) (mh t)) 1))))
(declare-fun bal (Int list) tree_list_pair)
(assert (forall ((n Int) (xs list)) (= (bal n xs) (ite (= n 0) (tlp Leaf xs)
  (let ((m (div n 2))) (let ((lys (bal m xs))) (let ((rzs (bal (- n (+ 1 m)) (Cons_1 (tlp_1 lys)))))
    (tlp (Node (tlp_0 lys) (Cons_0 (tlp_1 lys)) (tlp_0 rzs)) (tlp_1 rzs)))))))))
(declare-fun bal_list (Int list) tree)
(assert (forall ((n Int) (xs list)) (= (bal_list n xs) (tlp_0 (bal n xs)))))
(declare-fun balance_list (list) tree)
(assert (forall ((xs list)) (= (balance_list xs) (bal_list (len_list xs) xs))))
(declare-fun bal_tree (Int tree) tree)
(assert (forall ((n Int) (t tree)) (= (bal_tree n t) (bal_list n (inorder t)))))
(declare-fun balance_tree (tree) tree)
(assert (forall ((t tree)) (= (balance_tree t) (bal_tree (size t) t))))
(declare-fun bst (tree) Bool)
(assert (bst Leaf))
(assert (forall ((l tree) (a Int) (r tree)) (= (bst (Node l a r))
  (and (forall ((x Int)) (=> (in_set_tree x l) (< x a))) (forall ((x Int)) (=> (in_set_tree x l) (< a x))) (bst l) (bst r)))))
(declare-fun cmp (Int Int) cmp_val)
(assert (forall ((x Int) (y Int)) (= (cmp x y) (ite (< x y) LT (ite (= x y) EQ GT)))))
(declare-fun empty () tree)
(assert (= empty Leaf))
(declare-fun isin (tree Int) Bool)
(assert (forall ((x Int)) (not (isin Leaf x))))
(assert (forall ((x Int) (l tree) (a Int) (r tree)) (= (isin (Node l a r) x)
  (let ((c (cmp x a))) (match c ((LT (isin l x)) (EQ true) (GT (isin r x))))))))
(declare-fun insert (Int tree) tree)
(assert (forall ((x Int)) (= (insert x Leaf) (Node Leaf x Leaf))))
(assert (forall ((x Int) (l tree) (a Int) (r tree)) (= (insert x (Node l a r))
  (let ((c (cmp x a))) (match c ((LT (Node (insert x l) a r))
                                 (EQ (Node l a r))
                                 (GT (Node l a (insert x r)))))))))
(declare-fun split_min (tree) int_tree_pair)
(assert (forall ((l tree) (a Int) (r tree)) (= (split_min (Node l a r))
  (ite (= l Leaf) (itp a r) (let ((xl (split_min l))) (itp (itp_0 xl) (Node (itp_1 xl) a r)))))))
(declare-fun delete (Int tree) tree)
(assert (forall ((x Int)) (= (delete x Leaf) Leaf)))
(assert (forall ((x Int) (l tree) (a Int) (r tree)) (= (delete x (Node l a r))
  (let ((c (cmp x a))) (match c ((LT (Node (delete x l) a r))
                                 (EQ (ite (= r Leaf) l (let ((ar (split_min r))) (Node l (itp_0 ar) (itp_1 ar)))))
                                 (GT (Node l a (delete x r)))))))))

(declare-fun join (tree tree) tree)
(assert (forall ((t tree)) (= (join t Leaf) t)))
(assert (forall ((t tree)) (= (join Leaf t) t)))
(assert (forall ((t1 tree) (a Int) (t2 tree) (t3 tree) (b Int) (t4 tree)) (= (join (Node t1 a t2) (Node t3 b t4))
  (let ((j (join t2 t3))) (match j ((Leaf (Node t1 a (Node Leaf b t4))) ((Node u2 x u3) (Node (Node t1 a u2) x (Node u3 b t4)))))))))
(declare-fun delete2 (Int tree) tree)
(assert (forall ((x Int)) (= (delete2 x Leaf) Leaf)))
(assert (forall ((x Int) (l tree) (a Int) (r tree)) (= (delete2 x (Node l a r))
  (let ((c (cmp x a))) (match c ((LT (Node (delete2 x l) a r))
                                 (EQ (join l r))
                                 (GT (Node l a (delete2 x r)))))))))

(declare-fun join0 (tree tree) tree)
(assert (forall ((t tree)) (= (join0 t Leaf) t)))
(assert (forall ((t tree)) (= (join0 Leaf t) t)))
(assert (forall ((t1 tree) (a Int) (t2 tree) (t3 tree) (b Int) (t4 tree))
  (= (join0 (Node t1 a t2) (Node t3 b t4)) (Node t1 a (Node (join0 t2 t3) b t4)))))

(declare-fun ins_list (Int list) list)
(assert (forall ((x Int)) (= (ins_list x Nil) (Cons x Nil))))
(assert (forall ((x Int) (a Int) (xs list)) (= (ins_list x (Cons a xs))
  (ite (< x a) (Cons x (Cons a xs)) (ite (= x a) (Cons a xs) (Cons a (ins_list x xs)))))))
(declare-fun del_list (Int list) list)
(assert (forall ((x Int)) (= (del_list x Nil) Nil)))
(assert (forall ((x Int) (a Int) (xs list)) (= (del_list x (Cons a xs))
  (ite (= x a) xs (Cons a (del_list x xs))))))

(declare-fun iisin (itree Int) Bool)
(assert (forall ((x Int)) (not (iisin ILeaf x))))
(assert (forall ((l itree) (a Int) (b Int) (r itree) (x Int)) (= (iisin (INode l a b r) x)
  (let ((c (cmp x a))) (match c ((LT (iisin l x)) (EQ true) (GT (iisin r x))))))))