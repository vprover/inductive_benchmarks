; TODO try replacing this with int
(declare-datatype nat ((zero) (s (s_0 nat))))

(declare-fun plus (nat nat) nat)
(assert (forall ((x nat)) (= (plus zero x) x)))
(assert (forall ((x nat) (y nat)) (= (plus (s x) y) (s (plus x y)))))
(declare-fun mult (nat nat) nat)
(assert (forall ((x nat)) (= (mult zero x) zero)))
(assert (forall ((x nat) (y nat)) (= (mult (s x) y) (plus (mult x y) y))))
(declare-fun minus (nat nat) nat)
(assert (forall ((n nat)) (= (minus zero n) zero) ))
(assert (forall ((n nat)) (= (minus n zero) n) ))
(assert (forall ((n nat) (m nat)) (= (minus (s n) (s m)) (minus n m)) ))

(declare-datatype list (par (a) ((Nil) (Cons (Cons_0 a) (Cons_1 (list a))))))
(define-sort lists (a) (list (list a)))
(declare-datatype option (par (a) ((None) (Some (Some_0 a)))))
(declare-datatype tree (par (a) ((Leaf) (Node (Node_0 (tree a)) (Node_1 a) (Node_2 (tree a))))))
(declare-datatype pair (par (a b) ((Pair (Pair_0 a) (Pair_1 b)))))
(define-sort ptree (a b) (tree (pair a b)))
(declare-const LeafP (par (a b) (ptree a b)))
(assert (par (a b) (= (LeafP a b) (Leaf (pair a b)))))
(declare-fun NodeP (par (a b) ((ptree a b) a b (ptree a b)) (ptree a b)))
(assert (par (a b) (forall ((l (ptree a b)) (x a) (y b) (r (ptree a b))) (= (NodeP a b l x y r) (Node (pair a b) l (Pair a b x y) r)))))
(define-sort ivl (a) (pair a a))
(define-sort itree (a) (ptree (ivl a) a))
(declare-datatype cmp_val ((LT) (EQ) (GT)))
(declare-datatype tree23 (par (a) ((Leaf23) (Node2 (Node2_0 (tree23 a)) (Node2_1 a) (Node2_2 (tree23 a))) (Node3 (Node3_0 (tree23 a)) (Node3_1 a) (Node3_2 (tree23 a)) (Node3_3 a) (Node3_4 (tree23 a))))))
(declare-datatype upI (par (a) ((TI (TI_0 (tree23 a))) (OF (OF_0 (tree23 a)) (OF_1 a) (OF_2 (tree23 a))))))
(declare-datatype upD (par (a) ((TD (TD_0 (tree23 a))) (UF (UF_0 (tree23 a))))))
(declare-datatype tree23s (par (a) ((T (T_0 (tree23 a))) (TTs (TTs_0 (tree23 a)) (TTs_1 a) (TTs_2 (tree23s a))))))
(declare-datatype color ((Red) (Black)))
(declare-datatype unit ((Unit)))
(declare-datatype bal ((Lh) (Bal) (Rh)))
(define-sort tree_bal (a) (ptree a bal))
;(declare-datatype tree4 ((Leaf4) (Lh (Lh_0 tree4) (Lh_1 nat) (Lh_2 tree4)) (Bal (Bal_0 tree4) (Bal_1 nat) (Bal_2 tree4)) (Rh (Rh_0 tree4) (Rh_1 nat) (Rh_2 tree4))))
;(declare-datatype trie ((Nd Bool ('a -> 'a trie option))))
(declare-datatype trie ((Lf) (Nd (Nd_0 Bool) (Nd_1 trie) (Nd_2 trie))))
(declare-datatype trieP ((LfP) (NdP (NdP_0 (list Bool)) (NdP_1 Bool) (NdP_2 trieP) (NdP_3 trieP))))
;(declare-datatype rbt (par (a) ((LeafRB) (NodeRB (NodeR_0 (rbt a)) (NodeR_1 (pair a color)) (NodeR_2 (rbt a))))))
(define-sort rbt (a) (ptree a color))
(declare-datatype treeh (par (a) ((LeafH (LeafH_0 nat) (LeafH_1 a)) (NodeH (NodeH_0 nat) (NodeH_1 (treeh a)) (NodeH_2 (treeh a))))))
(define-sort tree_ht (a) (ptree a nat))
(declare-datatype triple (par (a b c) ((Triple (Triple_0 a) (Triple_1 b) (Triple_2 c)))))
(define-sort lheap (a) (ptree a nat))

; uninterpreted functions
(declare-fun f (par (a) ((list a)) (list a)))

; auxiliary functions for sets and multisets -- remove these once a higher-order setting is used
(declare-fun in_set (par (a) (a (list a)) Bool))
(assert (par (a) (forall ((x a)) (not (in_set a x (Nil a))))))
(assert (par (a) (forall ((x a) (y a) (ys (list a))) (= (in_set a x (Cons a y ys)) (or (= x y) (in_set a x ys))))))
(declare-fun in_set_tree (par (a) (a (tree a)) Bool))
(assert (par (a) (forall ((x a)) (not (in_set_tree a x (Leaf a))))))
(assert (par (a) (forall ((x a) (l (tree a)) (y a) (r (tree a))) (= (in_set_tree a x (Node a l y r)) (or (= x y) (in_set_tree a x l) (in_set_tree a x r))))))
(declare-fun in_set_ptree (par (a b) (a (ptree a b)) Bool))
(assert (par (a b) (forall ((x a)) (not (in_set_ptree a b x (LeafP a b))))))
(assert (par (a b) (forall ((x a) (l (ptree a b)) (y a) (z b) (r (ptree a b))) (= (in_set_ptree a b x (NodeP a b l y z r)) (or (= x y) (in_set_ptree a b x l) (in_set_ptree a b x r))))))
(declare-fun count (par (a) (a (list a)) nat))
(assert (par (a) (forall ((x a)) (= (count a x (Nil a)) zero))))
(assert (par (a) (forall ((x a) (y a) (ys (list a))) (= (count a x (Cons a y ys)) (ite (= x y) (s (count a x ys)) (count a x ys))))))
(declare-fun same_set (par (a) ((list a) (list a)) Bool))
(assert (par (a) (forall ((xs (list a)) (ys (list a))) (= (same_set a xs ys) (forall ((x a)) (= (in_set a x xs) (in_set a x ys)))))))
(declare-fun same_mset (par (a) ((list a) (list a)) Bool))
(assert (par (a) (forall ((xs (list a)) (ys (list a))) (= (same_mset a xs ys) (forall ((x a)) (= (count a x xs) (count a x ys)))))))
(declare-fun count_tree (par (a) (a (tree a)) nat))
(assert (par (a) (forall ((x a)) (= (count_tree a x (Leaf a)) zero))))
(assert (par (a) (forall ((x a) (l (tree a)) (y a) (r (tree a))) (= (count_tree a x (Node a l y r))
  (let ((lc (count_tree a x l)) (rc (count_tree a x r))) (ite (= x y) (s (plus lc rc)) (plus lc rc)))))))
(declare-fun count_ptree (par (a b) (a (ptree a b)) nat))
(assert (par (a b) (forall ((x a)) (= (count_ptree a b x (LeafP a b)) zero))))
(assert (par (a b) (forall ((x a) (l (ptree a b)) (y a) (z b) (r (ptree a b))) (= (count_ptree a b x (NodeP a b l y z r))
  (let ((lc (count_ptree a b x l)) (rc (count_ptree a b x r))) (ite (= x y) (s (plus lc rc)) (plus lc rc)))))))

; filter and map functions -- remove these once a higher-order setting is used
(declare-fun less (par (a) (a a) Bool))
(assert (forall ((x nat)) (not (less nat x zero))))
(assert (forall ((x nat)) (less nat zero (s x))))
(assert (forall ((x nat) (y nat)) (= (less nat (s x) (s y)) (less nat x y))))
(declare-fun leq (par (a) (a a) Bool))
(assert (par (a) (forall ((x a) (y a)) (= (leq a x y) (or (= x y) (less a x y))))))
(declare-fun filter_less (par (a) (a (list a)) (list a)))
(assert (par (a) (forall ((x a)) (= (filter_less a x (Nil a)) (Nil a)))))
(assert (par (a) (forall ((x a) (y a) (ys (list a))) (= (filter_less a x (Cons a y ys)) (ite (less a y x) (Cons a y (filter_less a x ys)) (filter_less a x ys))))))
(declare-fun filter_ge (par (a) (a (list a)) (list a)))
(assert (par (a) (forall ((x a)) (= (filter_ge a x (Nil a)) (Nil a)))))
(assert (par (a) (forall ((x a) (y a) (ys (list a))) (= (filter_ge a x (Cons a y ys)) (ite (not (less a y x)) (Cons a y (filter_ge a x ys)) (filter_ge a x ys))))))
(declare-fun map_list_lists (par (a) ((list a)) (lists a)))
(assert (par (a) (= (map_list_lists a (Nil a)) (Nil (list a)))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (map_list_lists a (Cons a x xs)) (Cons (list a) (Cons a x (Nil a)) (map_list_lists a xs))))))

; functions
(declare-fun pow (nat nat) nat)
(assert (forall ((x nat)) (= (pow x zero) (s zero))))
(assert (forall ((x nat) (e nat)) (= (pow x (s e)) (mult x (pow x e)))))
(declare-fun pow2 (nat) nat)
(assert (forall ((x nat)) (= (pow2 x) (pow (s (s zero)) x))))
(declare-fun fib (nat) nat)
(assert (= (fib zero) zero))
(assert (= (fib (s zero)) (s zero)))
(assert (forall ((n nat)) (= (fib (s (s n))) (plus (fib (s n)) (fib n)))))
(declare-fun in_range (nat nat nat) Bool)
(assert (forall ((x nat) (y nat) (z nat)) (= (in_range x y z) (and (leq nat y x) (leq nat x z)))))
(declare-fun div2 (nat) nat)
(assert (= (div2 zero) zero))
(assert (= (div2 (s zero)) zero))
(assert (forall ((n nat)) (= (div2 (s (s n))) (s (div2 n)))))
(declare-fun append (par (a) ((list a) (list a)) (list a)))
(assert (par (a) (forall ((ys (list a))) (= (append a (Nil a) ys) ys))))
(assert (par (a) (forall ((x a) (xs (list a)) (ys (list a))) (= (append a (Cons a x xs) ys) (Cons a x (append a xs ys))))))
(declare-fun len (par (a) ((list a)) nat))
(assert (par (a) (= (len a (Nil a)) zero)))
(assert (par (a) (forall ((x a) (xs (list a))) (= (len a (Cons a x xs)) (s (len a xs))))))
(declare-fun rev (par (a) ((list a)) (list a)))
(assert (par (a) (= (rev a (Nil a)) (Nil a))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (rev a (Cons a x xs)) (append a (rev a xs) (Cons a x (Nil a)))))))
(declare-fun itrev (par (a) ((list a) (list a)) (list a)))
(assert (par (a) (forall ((ys (list a))) (= (itrev a (Nil a) ys) ys))))
(assert (par (a) (forall ((x a) (xs (list a)) (ys (list a))) (= (itrev a (Cons a x xs) ys) (itrev a xs (Cons a x ys))))))
(declare-fun nth (par (a) ((list a) nat) a))
(assert (par (a) (forall ((x a) (xs (list a)) (n nat)) (= (nth a (Cons a x xs) n) (match n
  ((zero x)
   ((s k) (nth a xs k))))))))
(declare-fun upd (par (a) ((list a) nat a) (list a)))
(assert (par (a) (forall ((n nat) (x a)) (= (upd a (Nil a) n x) (Nil a)))))
(assert (par (a) (forall ((x a) (xs (list a)) (n nat) (y a)) (= (upd a (Cons a x xs) n y) (match n
  ((zero (Cons a y xs))
   ((s j) (Cons a x (upd a xs j y)))))))))
; extensionality
(assert (par (a) (forall ((xs (list a)) (ys (list a))) (= (= xs ys) (and (= (len a xs) (len a ys))
  (forall ((i nat)) (=> (less nat i (len a xs)) (= (nth a xs i) (nth a ys i)))))))))
(declare-fun butlast (par (a) ((list a)) (list a)))
(assert (par (a) (= (butlast a (Nil a)) (Nil a))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (butlast a (Cons a x xs))
  (ite (= xs (Nil a)) (Nil a) (Cons a x (butlast a xs)))))))
(declare-fun hd (par (a) ((list a)) a))
(assert (par (a) (forall ((x a) (xs (list a))) (= (hd a (Cons a x xs)) x))))
(declare-fun tl (par (a) ((list a)) (list a)))
(assert (par (a) (= (tl a (Nil a)) (Nil a))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (tl a (Cons a x xs)) xs))))
(declare-fun replicate (par (a) (nat a) (list a)))
(assert (par (a) (forall ((x a)) (= (replicate a zero x) (Nil a)))))
(assert (par (a) (forall ((n nat) (x a)) (= (replicate a (s n) x) (Cons a x (replicate a n x))))))
(declare-fun T_append (par (a) ((list a) (list a)) nat))
(assert (par (a) (forall ((ys (list a))) (= (T_append a (Nil a) ys) (s zero)))))
(assert (par (a) (forall ((x a) (xs (list a)) (ys (list a))) (= (T_append a (Cons a x xs) ys) (s (T_append a xs ys))))))
(declare-fun T_rev (par (a) ((list a)) nat))
(assert (par (a) (= (T_rev a (Nil a)) (s zero))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (T_rev a (Cons a x xs)) (s (plus (T_rev a xs) (T_append a (rev a xs) (Cons a x (Nil a)))))))))
(declare-fun T_itrev (par (a) ((list a) (list a)) nat))
(assert (par (a) (forall ((ys (list a))) (= (T_itrev a (Nil a) ys) (s zero)))))
(assert (par (a) (forall ((x a) (xs (list a)) (ys (list a))) (= (T_itrev a (Cons a x xs) ys) (s (T_itrev a xs (Cons a x ys)))))))
(declare-fun sorted (par (a) ((list a)) Bool))
(assert (par (a) (sorted a (Nil a))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (sorted a (Cons a x xs)) (and (forall ((y a)) (=> (in_set a y xs) (leq a x y))) (sorted a xs))))))
; this (strict) variant is used for trees where each element can be present in a tree only once
(declare-fun sorted_s (par (a) ((list a)) Bool))
(assert (par (a) (sorted_s a (Nil a))))
(assert (par (a) (forall ((x a)) (sorted_s a (Cons a x (Nil a))))))
(assert (par (a) (forall ((x a) (y a) (zs (list a))) (= (sorted_s a (Cons a x (Cons a y zs))) (and (less a x y) (sorted_s a (Cons a y zs)))))))
(declare-fun Ball_sorted (par (a) ((lists a)) Bool))
(assert (par (a) (Ball_sorted a (Nil (list a)))))
(assert (par (a) (forall ((xs (list a)) (xss (lists a))) (= (Ball_sorted a (Cons (list a) xs xss)) (and (sorted a xs) (Ball_sorted a xss))))))
(declare-fun insort (par (a) (a (list a)) (list a)))
(assert (par (a) (forall ((x a)) (= (insort a x (Nil a)) (Cons a x (Nil a))))))
(assert (par (a) (forall ((x a) (y a) (ys (list a))) (= (insort a x (Cons a y ys)) (ite (leq a x y) (Cons a x (Cons a y ys)) (Cons a y (insort a x ys)))))))
(declare-fun isort (par (a) ((list a)) (list a)))
(assert (par (a) (= (isort a (Nil a)) (Nil a))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (isort a (Cons a x xs)) (insort a x (isort a xs))))))
(declare-fun T_insort (par (a) (a (list a)) nat))
(assert (par (a) (forall ((x a)) (= (T_insort a x (Nil a)) (s zero)))))
(assert (par (a) (forall ((x a) (y a) (ys (list a))) (= (T_insort a x (Cons a y ys)) (s (ite (leq a x y) zero (T_insort a x ys)))))))
(declare-fun T_isort (par (a) ((list a)) nat))
(assert (par (a) (= (T_isort a (Nil a)) (s zero))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (T_isort a (Cons a x xs)) (s (plus (T_isort a xs) (T_insort a x (isort a xs))))))))
(declare-fun quicksort (par (a) ((list a)) (list a)))
(assert (par (a) (= (quicksort a (Nil a)) (Nil a))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (quicksort a (Cons a x xs))
  (append a (quicksort a (filter_less a x xs)) (append a (Cons a x (Nil a)) (quicksort a (filter_ge a x xs))))))))
(declare-fun quicksort2 (par (a) ((list a) (list a)) (list a)))
(assert (par (a) (forall ((ys (list a))) (= (quicksort2 a (Nil a) ys) ys))))
(assert (par (a) (forall ((x a) (xs (list a)) (ys (list a))) (= (quicksort2 a (Cons a x xs) ys)
  (quicksort2 a (filter_less a x xs) (Cons a x (quicksort2 a (filter_ge a x xs) ys)))))))
;(declare-fun partition3 (nat (list nat)) tuple((list nat),(list nat),(list nat)))
;(declare-fun quicksort3 ((list nat)) (list nat))
(declare-fun T_quicksort (par (a) ((list a)) nat))
(assert (par (a) (= (T_quicksort a (Nil a)) (s zero))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (T_quicksort a (Cons a x xs))
  (s (plus (T_quicksort a (filter_less a x xs)) (plus (T_quicksort a (filter_ge a x xs)) (mult (s (s zero)) (len a xs)))))))))
(declare-fun merge (par (a) ((list a) (list a)) (list a)))
(assert (par (a) (forall ((ys (list a))) (= (merge a (Nil a) ys) ys))))
(assert (par (a) (forall ((xs (list a))) (= (merge a xs (Nil a)) xs))))
(assert (par (a) (forall ((x a) (xs (list a)) (y a) (ys (list a))) (= (merge a (Cons a x xs) (Cons a y ys))
  (ite (leq a x y) (Cons a x (merge a xs (Cons a y ys))) (Cons a y (merge a (Cons a x xs) ys)))))))
(declare-fun take (par (a) (nat (list a)) (list a)))
(assert (par (a) (forall ((xs (list a))) (= (take a zero xs) (Nil a)))))
(assert (par (a) (forall ((n nat)) (= (take a n (Nil a)) (Nil a)))))
(assert (par (a) (forall ((n nat) (x a) (xs (list a))) (= (take a (s n) (Cons a x xs)) (Cons a x (take a n xs))))))
(declare-fun drop (par (a) (nat (list a)) (list a)))
(assert (par (a) (forall ((xs (list a))) (= (drop a zero xs) xs))))
(assert (par (a) (forall ((n nat)) (= (drop a n (Nil a)) (Nil a)))))
(assert (par (a) (forall ((n nat) (x a) (xs (list a))) (= (drop a (s n) (Cons a x xs)) (drop a n xs)))))
(declare-fun msort (par (a) ((list a)) (list a)))
(assert (par (a) (forall ((xs (list a))) (= (msort a xs) (let ((n (len a xs))) (ite (leq nat n (s zero)) xs
  (merge a (msort a (take a (div2 n) xs)) (msort a (drop a (div2 n) xs)))))))))
(declare-fun C_merge (par (a) ((list a) (list a)) nat))
(assert (par (a) (forall ((ys (list a))) (= (C_merge a (Nil a) ys) zero))))
(assert (par (a) (forall ((xs (list a))) (= (C_merge a xs (Nil a)) zero))))
(assert (par (a) (forall ((x a) (xs (list a)) (y a) (ys (list a))) (= (C_merge a (Cons a x xs) (Cons a y ys))
  (s (ite (leq a x y) (C_merge a xs (Cons a y ys)) (C_merge a (Cons a x xs) ys)))))))
(declare-fun C_msort (par (a) ((list a)) nat))
(assert (par (a) (forall ((xs (list a))) (= (C_msort a xs) (let ((n (len a xs))) (let ((ys (take a (div2 n) xs)) (zs (drop a (div2 n) xs)))
  (ite (leq nat n (s zero)) zero (plus (plus (C_msort a (ys a)) (C_msort a (zs a))) (C_merge a (msort a (ys a)) (msort a (zs a)))))))))))
(declare-fun halve (par (a) ((list a) (list a) (list a)) (pair (list a) (list a))))
(assert (par (a) (forall ((xs (list a)) (ys (list a))) (= (halve a (Nil a) xs ys) (Pair (list a) (list a) xs ys)))))
(assert (par (a) (forall ((x a) (xs (list a)) (ys (list a))) (= (halve a (Cons a x (Nil a)) xs ys)
  (Pair (list a) (list a) (Cons a x xs) ys)))))
(assert (par (a) (forall ((x a) (y a) (zs (list a)) (xs (list a)) (ys (list a))) (= (halve a (Cons a x (Cons a y zs)) xs ys)
  (halve a zs (Cons a x xs) (Cons a y ys))))))
(declare-fun msort2 (par (a) ((list a)) (list a)))
(assert (par (a) (= (msort2 a (Nil a)) (Nil a))))
(assert (par (a) (forall ((x a)) (= (msort2 a (Cons a x (Nil a))) (Cons a x (Nil a))))))
(assert (par (a) (forall ((x1 a) (x2 a) (xs (list a))) (= (msort2 a (Cons a x1 (Cons a x2 xs)))
  (let ((p (halve a (Cons a x1 (Cons a x2 xs)) (Nil a) (Nil a)))) (merge a (msort2 a (Pair_0 (list a) (list a) (p a))) (msort2 a (Pair_1 (list a) (list a) (p a)))))))))
(declare-fun merge_adj (par (a) ((lists a)) (lists a)))
(assert (par (a) (= (merge_adj a (Nil (list a))) (Nil (list a)))))
(assert (par (a) (forall ((xs (list a))) (= (merge_adj a (Cons (list a) xs (Nil (list a)))) (Cons (list a) xs (Nil (list a)))))))
(assert (par (a) (forall ((xs (list a)) (ys (list a)) (zss (lists a))) (= (merge_adj a (Cons (list a) xs (Cons (list a) ys zss)))
  (Cons (list a) (merge a xs ys) (merge_adj a zss))))))
(declare-fun merge_all (par (a) ((lists a)) (list a)))
(assert (par (a) (= (merge_all a (Nil (list a))) (Nil a))))
(assert (par (a) (forall ((xs (list a))) (= (merge_all a (Cons (list a) xs (Nil (list a)))) xs))))
(assert (par (a) (forall ((xs (list a)) (xss (lists a))) (=> (distinct xss (Cons (list a) xs (Nil (list a))))
  (= (merge_all a xss) (merge_all a (merge_adj a xss)))))))
(declare-fun msort_bu (par (a) ((list a)) (list a)))
(assert (par (a) (forall ((xs (list a))) (= (msort_bu a xs) (merge_all a (map_list_lists a xs))))))
(declare-fun C_merge_adj (par (a) ((lists a)) nat))
(assert (par (a) (= (C_merge_adj a (Nil (list a))) zero)))
(assert (par (a) (forall ((xs (list a))) (= (C_merge_adj a (Cons (list a) xs (Nil (list a)))) zero))))
(assert (par (a) (forall ((xs (list a)) (ys (list a)) (zss (lists a))) (= (C_merge_adj a (Cons (list a) xs (Cons (list a) ys zss)))
  (plus (C_merge a xs ys) (C_merge_adj a zss))))))
(declare-fun C_merge_all (par (a) ((lists a)) nat))
(assert (par (a) (= (C_merge_all a (Nil (list a))) zero)))
(assert (par (a) (forall ((xs (list a))) (= (C_merge_all a (Cons (list a) xs (Nil (list a)))) zero))))
(assert (par (a) (forall ((xs (list a)) (xss (lists a))) (=> (and (distinct xss (Cons (list a) xs (Nil (list a)))) (distinct xss (Nil (list a))))
  (= (C_merge_all a xss) (plus (C_merge_adj a xss) (C_merge_all a (merge_adj a xss))))))))
(declare-fun C_msort_bu (par (a) ((list a)) nat))
(assert (par (a) (forall ((xs (list a))) (= (C_msort_bu a xs) (C_merge_all a (map_list_lists a xs))))))
(declare-fun even (nat) Bool)
(assert (even zero))
(assert (forall ((x nat)) (= (even (s x)) (not (even x)))))
;(assert (forall ((n nat)) (= (even n) (= (div n 2) 0))))
(declare-fun odd (nat) Bool)
(assert (not (odd zero)))
(assert (forall ((x nat)) (= (odd (s x)) (not (odd x)))))
;(assert (forall ((n nat)) (= (odd n) (= (div n 2) 1))))
(declare-fun runs (par (a) ((list a)) (lists a)))
(assert (par (a) (= (runs a (Nil a)) (Nil (list a)))))
(assert (par (a) (forall ((x a)) (= (runs a (Cons a x (Nil a))) (Cons (list a) (Cons a x (Nil a)) (Nil (list a)))))))
;(assert (forall ((a nat) (b nat) (xs (list nat))) (= (runs (Cons nat a (Cons nat b xs)))
;  (ite (< b a) (desc b (Cons nat a (Nil nat)) xs) (asc b ((# a) xs))))))
;(declare-fun asc (nat (=> (list nat) (list nat)) (list nat)) (lists nat))
;(assert (forall ((a nat) (xs (list nat))) (= (asc a xs (Nil nat)) (Cons (list nat) xs (Cons (list nat) (Cons nat a (Nil nat)) (Nil (list nat)))))))
;(assert (forall ((a nat) (xs (list nat)) (b nat) (ys (list nat))) (= (asc a xs (Cons nat b ys))
;  (ite (not (< b a)) (asc b (xs . (#) a) ys) (Cons (list nat) (xs (Cons nat a (Nil nat))) (runs (Cons nat b ys)))))))
(declare-fun desc (par (a) (a (list a) (list a)) (lists a)))
(assert (par (a) (forall ((x a) (xs (list a))) (= (desc a x xs (Nil a)) (Cons (list a) (Cons a x xs) (Nil (list a)))))))
(assert (par (a) (forall ((x a) (xs (list a)) (y a) (ys (list a))) (= (desc a x xs (Cons a y ys))
  (ite (less a y x) (desc a y (Cons a x xs) ys) (Cons (list a) (Cons a x xs) (runs a (Cons a y ys))))))))
(declare-fun nmsort (par (a) ((list a)) (list a)))
(assert (par (a) (forall ((xs (list a))) (= (nmsort a xs) (merge_all a (runs a xs))))))
;(declare-fun Ball (nat (=> nat Bool)) Bool)
(declare-fun C_runs (par (a) ((list a)) nat))
(declare-fun C_asc (par (a) (a (list a)) nat))
(assert (par (a) (forall ((x a)) (= (C_asc a x (Nil a)) zero))))
(assert (par (a) (forall ((x a) (y a) (ys (list a))) (= (C_asc a x (Cons a y ys))
  (s (ite (not (less a y x)) (C_asc a y ys) (C_runs a (Cons a y ys))))))))
(declare-fun C_desc (par (a) (a (list a)) nat))
(assert (par (a) (forall ((x a)) (= (C_desc a x (Nil a)) zero))))
(assert (par (a) (forall ((x a) (y a) (ys (list a))) (= (C_desc a x (Cons a y ys))
  (s (ite (less a y x) (C_desc a y ys) (C_runs a (Cons a y ys))))))))
(assert (par (a) (= (C_runs a (Nil a)) zero)))
(assert (par (a) (forall ((x a)) (= (C_runs a (Cons a x (Nil a))) zero))))
(assert (par (a) (forall ((x a) (y a) (xs (list a))) (= (C_runs a (Cons a x (Cons a y xs)))
  (s (ite (less a y x) (C_desc a y xs) (C_asc a y xs)))))))
(declare-fun C_nmsort (par (a) ((list a)) nat))
(assert (par (a) (forall ((xs (list a))) (= (C_nmsort a xs) (plus (C_runs a xs) (C_merge_all a (runs a xs)))))))
(declare-fun concat (par (a) ((lists a)) (list a)))
(assert (par (a) (= (concat a (Nil (list a))) (Nil a))))
(assert (par (a) (forall ((xs (list a)) (xss (lists a))) (= (concat a (Cons (list a) xs xss)) (append a xs (concat a xss))))))
(declare-fun lg (nat) Real)
(declare-fun ceil (Real) nat)
(declare-fun floor (Real) nat)
;(declare-fun filter ((=> nat nat) (list nat)) (list nat))
;(declare-fun sort_key ((=> nat nat) (list nat)) (list nat))
;(declare-fun insort_key ((=> nat nat) nat (list nat)) (list nat))
;(declare-fun isort_key ((=> nat nat) (list nat)) (list nat))
; already declared
;(declare-fun select (nat (list nat)) nat)
;(declare-fun minus (nat nat) nat)
;(declare-fun select0 ((list nat)) nat)
;(declare-fun select1 ((list nat)) nat)
; already declared
;(declare-fun distinct ((list nat)) Bool)
(declare-fun median (par (a) ((list a)) a))
(declare-fun chop (nat (list nat)) (lists nat))
(declare-fun min (nat nat) nat)
(assert (forall ((x nat) (y nat)) (= (min x y) (ite (leq nat x y) x y))))
(declare-fun max (par (a) (a a) a))
(assert (par (a) (forall ((x a) (y a)) (= (max a x y) (ite (leq a x y) y x)))))

(declare-fun inorder (par (a) ((tree a)) (list a)))
(assert (par (a) (= (inorder a (Leaf a)) (Nil a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (inorder a (Node a l x r)) (append a (inorder a l) (append a (Cons a x (Nil a)) (inorder a r)))))))
(declare-fun inorder2 (par (a) ((tree a) (list a)) (list a)))
(assert (par (a) (forall ((xs (list a))) (= (inorder2 a (Leaf a) xs) xs))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a)) (xs (list a))) (= (inorder2 a (Node a l x r) xs) (inorder2 a l (Cons a x (inorder2 a r xs)))))))
(declare-fun preorder (par (a) ((tree a)) (list a)))
(assert (par (a) (= (preorder a (Leaf a)) (Nil a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (preorder a (Node a l x r)) (Cons a x (append a (preorder a l) (preorder a r)))))))
(declare-fun size (par (a) ((tree a)) nat))
(assert (par (a) (= (size a (Leaf a)) zero)))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (size a (Node a l x r)) (s (plus (size a l) (size a r)))))))
(declare-fun size1 (par (a) ((tree a)) nat))
(assert (par (a) (= (size1 a (Leaf a)) (s zero))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (size1 a (Node a l x r)) (plus (size1 a l) (size1 a r))))))
(declare-fun h (par (a) ((tree a)) nat))
(assert (par (a) (= (h a (Leaf a)) zero)))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (h a (Node a l x r)) (s (max nat (h a l) (h a r)))))))
(declare-fun mh (par (a) ((tree a)) nat))
(assert (par (a) (= (mh a (Leaf a)) zero)))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (mh a (Node a l x r)) (s (min (mh a l) (mh a r)))))))
(declare-fun lh (par (a) ((tree a)) nat))
(assert (par (a) (= (lh a (Leaf a)) zero)))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (lh a (Node a l x r)) (s (lh a l))))))
(declare-fun complete (par (a) ((tree a)) Bool))
(assert (par (a) (complete a (Leaf a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (complete a (Node a l x r)) (and (= (h a l) (h a r)) (complete a l) (complete a r))))))
(declare-fun acomplete (par (a) ((tree a)) Bool))
(assert (par (a) (forall ((t (tree a))) (= (acomplete a t) (leq nat (minus (h a t) (mh a t)) (s zero))))))
(declare-fun balance (par (a) (nat (list a)) (pair (tree a) (list a))))
(assert (par (a) (forall ((n nat) (xs (list a))) (= (balance a n xs) (ite (= n zero) (Pair (tree a) (list a) (Leaf a) xs)
  (let ((m (div2 n))) (let ((lys (balance a m xs))) (let ((rzs (balance a (minus n (s m)) (Cons_1 a (Pair_1 (tree a) (list a) (lys a))))))
    (Pair (tree a) (list a) (Node a (Pair_0 (tree a) (list a) (lys a)) (Cons_0 a (Pair_1 (tree a) (list a) (lys a))) (Pair_0 (tree a) (list a) (rzs a))) (Pair_1 (tree a) (list a) (rzs a)))))))))))
(declare-fun bal_list (par (a) (nat (list a)) (tree a)))
(assert (par (a) (forall ((n nat) (xs (list a))) (= (bal_list a n xs) (Pair_0 (tree a) (list a) (balance a n xs))))))
(declare-fun balance_list (par (a) ((list a)) (tree a)))
(assert (par (a) (forall ((xs (list a))) (= (balance_list a xs) (bal_list a (len a xs) xs)))))
(declare-fun bal_tree (par (a) (nat (tree a)) (tree a)))
(assert (par (a) (forall ((n nat) (t (tree a))) (= (bal_tree a n t) (bal_list a n (inorder a t))))))
(declare-fun balance_tree (par (a) ((tree a)) (tree a)))
(assert (par (a) (forall ((t (tree a))) (= (balance_tree a t) (bal_tree a (size a t) t)))))
(declare-fun bst (par (a) ((tree a)) Bool))
(assert (par (a) (bst a (Leaf a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (bst a (Node a l x r))
  (and (forall ((y a)) (=> (in_set_tree a y l) (less a y x))) (forall ((y a)) (=> (in_set_tree a y r) (less a x y))) (bst a l) (bst a r))))))
(declare-fun cmp (par (a) (a a) cmp_val))
(assert (par (a) (forall ((x a) (y a)) (= (cmp a x y) (ite (less a x y) LT (ite (= x y) EQ GT))))))
(declare-const empty (par (a) (tree a)))
(assert (par (a) (= (empty a) (Leaf a))))
(declare-fun isin (par (a) ((tree a) a) Bool))
(assert (par (a) (forall ((x a)) (not (isin a (Leaf a) x)))))
(assert (par (a) (forall ((x a) (l (tree a)) (y a) (r (tree a))) (= (isin a (Node a l y r) x)
  (match (cmp a x y) ((LT (isin a l x)) (EQ true) (GT (isin a r x))))))))
(declare-fun insert (par (a) (a (tree a)) (tree a)))
(assert (par (a) (forall ((x a)) (= (insert a x (Leaf a)) (Node a (Leaf a) x (Leaf a))))))
(assert (par (a) (forall ((x a) (l (tree a)) (y a) (r (tree a))) (= (insert a x (Node a l y r))
  (match (cmp a x y) ((LT (Node a (insert a x l) y r))
                      (EQ (Node a l y r))
                      (GT (Node a l y (insert a x r)))))))))
(declare-fun split_min (par (a) ((tree a)) (pair a (tree a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (split_min a (Node a l x r))
  (ite (= l (Leaf a)) (Pair a (tree a) x r) (let ((xl (split_min a l))) (Pair a (tree a) (Pair_0 a (tree a) (xl a)) (Node a (Pair_1 a (tree a) (xl a)) x r))))))))
(declare-fun delete (par (a) (a (tree a)) (tree a)))
(assert (par (a) (forall ((x a)) (= (delete a x (Leaf a)) (Leaf a)))))
(assert (par (a) (forall ((x a) (l (tree a)) (y a) (r (tree a))) (= (delete a x (Node a l y r))
  (match (cmp a x y) ((LT (Node a (delete a x l) y r))
                      (EQ (ite (= r (Leaf a)) l (let ((ar (split_min a r))) (Node a l (Pair_0 a (tree a) (ar a)) (Pair_1 a (tree a) (ar a))))))
                      (GT (Node a l y (delete a x r)))))))))

(declare-fun join (par (a) ((tree a) (tree a)) (tree a)))
(assert (par (a) (forall ((t (tree a))) (= (join a t (Leaf a)) t))))
(assert (par (a) (forall ((t (tree a))) (= (join a (Leaf a) t) t))))
(assert (par (a) (forall ((t1 (tree a)) (x a) (t2 (tree a)) (t3 (tree a)) (y a) (t4 (tree a))) (= (join a (Node a t1 x t2) (Node a t3 y t4))
  (match (join a t2 t3) (((Leaf a) (Node a t1 x (Node a (Leaf a) y t4))) ((Node a u2 z u3) (Node a (Node a t1 x u2) z (Node a u3 y t4)))))))))
(declare-fun delete2 (par (a) (a (tree a)) (tree a)))
(assert (par (a) (forall ((x a)) (= (delete2 a x (Leaf a)) (Leaf a)))))
(assert (par (a) (forall ((x a) (l (tree a)) (y a) (r (tree a))) (= (delete2 a x (Node a l y r))
  (match (cmp a x y) ((LT (Node a (delete2 a x l) y r))
                      (EQ (join a l r))
                      (GT (Node a l y (delete2 a x r)))))))))

(declare-fun join0 (par (a) ((tree a) (tree a)) (tree a)))
(assert (par (a) (forall ((t (tree a))) (= (join0 a t (Leaf a)) t))))
(assert (par (a) (forall ((t (tree a))) (= (join0 a (Leaf a) t) t))))
(assert (par (a) (forall ((t1 (tree a)) (x a) (t2 (tree a)) (t3 (tree a)) (y a) (t4 (tree a)))
  (= (join0 a (Node a t1 x t2) (Node a t3 y t4)) (Node a t1 x (Node a (join0 a t2 t3) y t4))))))

(declare-fun ins_list (par (a) (a (list a)) (list a)))
(assert (par (a) (forall ((x a)) (= (ins_list a x (Nil a)) (Cons a x (Nil a))))))
(assert (par (a) (forall ((x a) (y a) (xs (list a))) (= (ins_list a x (Cons a y xs))
  (ite (less a x y) (Cons a x (Cons a y xs)) (ite (= x y) (Cons a y xs) (Cons a y (ins_list a x xs))))))))
(declare-fun del_list (par (a) (a (list a)) (list a)))
(assert (par (a) (forall ((x a)) (= (del_list a x (Nil a)) (Nil a)))))
(assert (par (a) (forall ((x a) (y a) (xs (list a))) (= (del_list a x (Cons a y xs))
  (ite (= x y) xs (Cons a y (del_list a x xs)))))))

; interval trees
; this function is supposed to be the minimal element of type 'a'
(declare-const bot (par (a) a))
(declare-fun low (par (a) ((ivl a)) a))
(assert (par (a) (forall ((x (ivl a))) (= (low a x) (Pair_0 a a x)))))
(declare-fun high (par (a) ((ivl a)) a))
(assert (par (a) (forall ((x (ivl a))) (= (high a x) (Pair_1 a a x)))))
; comparison overrides
(assert (par (a) (forall ((x (ivl a)) (y (ivl a))) (= (less (ivl a) x y) (or (less a (low a x) (low a y))
  (and (= (low a x) (low a y)) (less a (high a x) (high a y))))))))
(assert (par (a) (forall ((x (ivl a)) (y (ivl a))) (= (leq (ivl a) x y) (or (less a (low a x) (low a y))
  (and (= (low a x) (low a y)) (leq a (high a x) (high a y))))))))
; these shouldn't be needed anywhere since the inorderp below overcomes the issue of inorder
; traversing an augmented tree
;(assert (par (a) (forall ((x (pair (ivl a) a)) (y (pair (ivl a) a))) (= (less (pair (ivl a) a) x y)
;  (less (ivl a) (Pair_0 (ivl a) a x) (Pair_0 (ivl a) a y))))))
;(assert (par (a) (forall ((x (pair (ivl a) a)) (y (pair (ivl a) a))) (= (leq (pair (ivl a) a) x y)
;  (leq (ivl a) (Pair_0 (ivl a) a x) (Pair_0 (ivl a) a y))))))
(declare-fun isinp (par (a b) ((ptree a b) a) Bool))
(assert (par (a b) (forall ((x a)) (not (isinp a b (LeafP a b) x)))))
(assert (par (a b) (forall ((l (ptree a b)) (x a) (y b) (r (ptree a b)) (z a)) (= (isinp a b (NodeP a b l x y r) z)
  (match (cmp a z x) ((LT (isinp a b l z)) (EQ true) (GT (isinp a b r z))))))))
(declare-fun max_hi (par (a) ((itree a)) a))
(assert (par (a) (= (max_hi a (LeafP (ivl a) a)) (bot a))))
(assert (par (a) (forall ((l (itree a)) (x (ivl a)) (m a) (r (itree a))) (= (max_hi a (NodeP (ivl a) a l x m r)) m))))
(declare-fun max3 (par (a) ((ivl a) a a) a))
(assert (par (a) (forall ((x (ivl a)) (y a) (z a)) (= (max3 a x y z) (max a (high a x) (max a y z))))))
(declare-fun node_ivl (par (a) ((itree a) (ivl a) (itree a)) (itree a)))
(assert (par (a) (forall ((l (itree a)) (x (ivl a)) (r (itree a))) (= (node_ivl a l x r)
  (NodeP (ivl a) a l x (max3 a x (max_hi a l) (max_hi a r)) r)))))
(declare-fun inv_max_hi (par (a) ((itree a)) Bool))
(assert (par (a) (inv_max_hi a (LeafP (ivl a) a))))
(assert (par (a) (forall ((l (itree a)) (x (ivl a)) (m a) (r (itree a))) (= (inv_max_hi a (NodeP (ivl a) a l x m r))
  (and (= m (max3 a x (max_hi a l) (max_hi a r))) (inv_max_hi a l) (inv_max_hi a r))))))
(declare-fun inorderp (par (a b) ((ptree a b)) (list a)))
(assert (par (a b) (= (inorderp a b (LeafP a b)) (Nil a))))
(assert (par (a b) (forall ((l (ptree a b)) (x a) (y b) (r (ptree a b))) (= (inorderp a b (NodeP a b l x y r))
  (append a (inorderp a b l) (append a (Cons a x (Nil a)) (inorderp a b r)))))))
(declare-fun insert_ivl (par (a) ((ivl a) (itree a)) (itree a)))
(assert (par (a) (forall ((x (ivl a))) (= (insert_ivl a x (LeafP (ivl a) a)) (NodeP (ivl a) a (LeafP (ivl a) a) x (high a x) (LeafP (ivl a) a))))))
(assert (par (a) (forall ((x (ivl a)) (l (itree a)) (y (ivl a)) (z a) (r (itree a))) (= (insert_ivl a x (NodeP (ivl a) a l y z r))
  (match (cmp (ivl a) x y) ((LT (node_ivl a (insert_ivl a x l) y r))
                            (EQ (NodeP (ivl a) a l y z r))
                            (GT (node_ivl a l y (insert_ivl a x r)))))))))
(declare-fun split_min_ivl (par (a) ((itree a)) (pair (ivl a) (itree a))))
(assert (par (a) (forall ((l (itree a)) (x (ivl a)) (y a) (r (itree a))) (= (split_min_ivl a (NodeP (ivl a) a l x y r))
  (ite (= l (LeafP (ivl a) a)) (Pair (ivl a) (itree a) x r) (let ((xl (split_min_ivl a l)))
    (Pair (ivl a) (itree a) (Pair_0 (ivl a) (itree a) (xl a)) (node_ivl a (Pair_1 (ivl a) (itree a) (xl a)) x r))))))))
(declare-fun delete_ivl (par (a) ((ivl a) (itree a)) (itree a)))
(assert (par (a) (forall ((x (ivl a))) (= (delete_ivl a x (LeafP (ivl a) a)) (LeafP (ivl a) a)))))
(assert (par (a) (forall ((x (ivl a)) (l (itree a)) (y (ivl a)) (z a) (r (itree a))) (= (delete_ivl a x (NodeP (ivl a) a l y z r))
  (match (cmp (ivl a) x y) ((LT (node_ivl a (delete_ivl a x l) y r))
                            (EQ (ite (= r (LeafP (ivl a) a)) l (let ((xy (split_min_ivl a r)))
                              (node_ivl a l (Pair_0 (ivl a) (itree a) (xy a)) (Pair_1 (ivl a) (itree a) (xy a))))))
                            (GT (node_ivl a l y (delete_ivl a x r)))))))))

; 2-3 trees
(declare-fun size23 (par (a) ((tree23 a)) nat))
(assert (par (a) (= (size23 a (Leaf23 a)) zero)))
(assert (par (a) (forall ((l (tree23 a)) (x a) (r (tree23 a))) (= (size23 a (Node2 a l x r))
  (s (plus (size23 a l) (size23 a r)))))))
(assert (par (a) (forall ((l (tree23 a)) (x a) (m (tree23 a)) (y a) (r (tree23 a)))
  (= (size23 a (Node3 a l x m y r)) (s (plus (size23 a l) (plus (size23 a m) (size23 a r))))))))
(declare-fun h23 (par (a) ((tree23 a)) nat))
(assert (par (a) (= (h23 a (Leaf23 a)) zero)))
(assert (par (a) (forall ((l (tree23 a)) (x a) (r (tree23 a))) (= (h23 a (Node2 a l x r))
  (s (max nat (h23 a l) (h23 a r)))))))
(assert (par (a) (forall ((l (tree23 a)) (x a) (m (tree23 a)) (y a) (r (tree23 a)))
  (= (h23 a (Node3 a l x m y r)) (s (max nat (h23 a l) (max nat (h23 a m) (h23 a r))))))))
(declare-fun hD (par (a) ((upD a)) nat))
(assert (par (a) (forall ((t (tree23 a))) (= (hD a (TD a t)) (h23 a t)))))
(assert (par (a) (forall ((t (tree23 a))) (= (hD a (UF a t)) (s (h23 a t))))))
(declare-fun complete23 (par (a) ((tree23 a)) Bool))
(assert (par (a) (complete23 a (Leaf23 a))))
(assert (par (a) (forall ((l (tree23 a)) (x a) (r (tree23 a))) (= (complete23 a (Node2 a l x r))
  (and (= (h23 a l) (h23 a r)) (complete23 a l) (complete23 a r))))))
(assert (par (a) (forall ((l (tree23 a)) (x a) (m (tree23 a)) (y a) (r (tree23 a))) (= (complete23 a (Node3 a l x m y r))
  (and (= (h23 a l) (h23 a m)) (= (h23 a m) (h23 a r)) (complete23 a l) (complete23 a m) (complete23 a r))))))
(declare-fun isin23 (par (a) ((tree23 a) a) Bool))
(assert (par (a) (forall ((x a)) (not (isin23 a (Leaf23 a) x)))))
(assert (par (a) (forall ((x a) (l (tree23 a)) (y a) (r (tree23 a))) (= (isin23 a (Node2 a l y r) x)
  (match (cmp a x y) ((LT (isin23 a l x)) (EQ true) (GT (isin23 a r x))))))))
(assert (par (a) (forall ((x a) (l (tree23 a)) (y a) (m (tree23 a)) (z a) (r (tree23 a))) (= (isin23 a (Node3 a l y m z r) x)
  (match (cmp a x y) ((LT (isin23 a l x)) (EQ true) (GT
  (match (cmp a x z) ((LT (isin23 a m x)) (EQ true) (GT (isin23 a r x)))))))))))

(declare-fun inorder23 (par (a) ((tree23 a)) (list a)))
(assert (par (a) (= (inorder23 a (Leaf23 a)) (Nil a))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a))) (= (inorder23 a (Node2 a t1 x t2))
  (append a (inorder23 a t1) (append a (Cons a x (Nil a)) (inorder23 a t2)))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a))) (= (inorder23 a (Node3 a t1 x t2 y t3))
  (append a (inorder23 a t1) (append a (Cons a x (Nil a)) (append a (inorder23 a t2) (append a (Cons a y (Nil a)) (inorder23 a t3)))))))))
(declare-fun treeI (par (a) ((upI a)) (tree23 a)))
(assert (par (a) (forall ((t (tree23 a))) (= (treeI a (TI a t)) t))))
(assert (par (a) (forall ((l (tree23 a)) (x a) (r (tree23 a))) (= (treeI a (OF a l x r)) (Node2 a l x r)))))
(declare-fun treeD (par (a) ((upD a)) (tree23 a)))
(assert (par (a) (forall ((t (tree23 a))) (= (treeD a (TD a t)) t))))
(assert (par (a) (forall ((t (tree23 a))) (= (treeD a (UF a t)) t))))
(declare-fun ins (par (a) (a (tree23 a)) (upI a)))
(assert (par (a) (forall ((x a)) (= (ins a x (Leaf23 a)) (OF a (Leaf23 a) x (Leaf23 a))))))
(assert (par (a) (forall ((x a) (l (tree23 a)) (y a) (r (tree23 a))) (= (ins a x (Node2 a l y r))
  (match (cmp a x y) ((LT (match (ins a x l) (((TI a ll) (TI a (Node2 a ll y r)))
                                              ((OF a l1 z l2) (TI a (Node3 a l1 z l2 y r))))))
                      (EQ (TI a (Node2 a l y r)))
                      (GT (match (ins a x r) (((TI a rr) (TI a (Node2 a l y rr)))
                                              ((OF a r1 z r2) (TI a (Node3 a l y r1 z r2))))))))))))
(assert (par (a) (forall ((x a) (l (tree23 a)) (y a) (m (tree23 a)) (z a) (r (tree23 a))) (= (ins a x (Node3 a l y m z r))
  (match (cmp a x y) ((LT (match (ins a x l) (((TI a ll) (TI a (Node3 a ll y m z r)))
                                              ((OF a l1 u l2) (OF a (Node2 a l1 u l2) y (Node2 a m z r))))))
                      (EQ (TI a (Node3 a l y m z r)))
                      (GT (match (cmp a x z) ((LT (match (ins a x m) (((TI a mm) (TI a (Node3 a l y mm z r)))
                                                                      ((OF a m1 u m2) (OF a (Node2 a l y m1) u (Node2 a m2 z r))))))
                                              (EQ (TI a (Node3 a l y m z r)))
                                              (GT (match (ins a x r) (((TI a rr) (TI a (Node3 a l y m z rr)))
                                                                      ((OF a r1 u r2) (OF a (Node2 a l y m) z (Node2 a r1 u r2)))))))))))))))
(declare-fun insert23 (par (a) (a (tree23 a)) (tree23 a)))
(assert (par (a) (forall ((x a) (t (tree23 a))) (= (insert23 a x t) (treeI a (ins a x t))))))
(declare-fun hI (par (a) ((upI a)) nat))
(assert (par (a) (forall ((t (tree23 a))) (= (hI a (TI a t)) (h23 a t)))))
(assert (par (a) (forall ((l (tree23 a)) (x a) (r (tree23 a))) (= (hI a (OF a l x r)) (h23 a l)))))
(declare-fun node21 (par (a) ((upD a) a (tree23 a)) (upD a)))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a))) (= (node21 a (TD a t1) x t2) (TD a (Node2 a t1 x t2))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a))) (= (node21 a (UF a t1) x (Node2 a t2 y t3))
  (UF a (Node3 a t1 x t2 y t3))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (t4 (tree23 a)))
  (= (node21 a (UF a t1) x (Node3 a t2 y t3 z t4)) (TD a (Node2 a (Node2 a t1 x t2) y (Node2 a t3 z t4)))))))
(declare-fun node22 (par (a) ((tree23 a) a (upD a)) (upD a)))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a))) (= (node22 a t1 x (TD a t2)) (TD a (Node2 a t1 x t2))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a))) (= (node22 a (Node2 a t1 x t2) y (UF a t3))
  (UF a (Node3 a t1 x t2 y t3))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (t4 (tree23 a)))
  (= (node22 a (Node3 a t1 x t2 y t3) z (UF a t4)) (TD a (Node2 a (Node2 a t1 x t2) y (Node2 a t3 z t4)))))))
(declare-fun node31 (par (a) ((upD a) a (tree23 a) a (tree23 a)) (upD a)))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a))) (= (node31 a (TD a t1) x t2 y t3)
  (TD a (Node3 a t1 x t2 y t3))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (t4 (tree23 a)))
  (= (node31 a (UF a t1) x (Node2 a t2 y t3) z t4) (TD a (Node2 a (Node3 a t1 x t2 y t3) z t4))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (t4 (tree23 a)) (u a) (t5 (tree23 a)))
  (= (node31 a (UF a t1) x (Node3 a t2 y t3 z t4) u t5) (TD a (Node3 a (Node2 a t1 x t2) y (Node2 a t3 z t4) u t5))))))
(declare-fun node32 (par (a) ((tree23 a) a (upD a) a (tree23 a)) (upD a)))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a))) (= (node32 a t1 x (TD a t2) y t3)
  (TD a (Node3 a t1 x t2 y t3))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (t4 (tree23 a)))
  (= (node32 a t1 x (UF a t2) y (Node2 a t3 z t4)) (TD a (Node2 a t1 x (Node3 a t2 y t3 z t4)))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (t4 (tree23 a)) (u a) (t5 (tree23 a)))
  (= (node32 a t1 x (UF a t2) y (Node3 a t3 z t4 u t5)) (TD a (Node3 a t1 x (Node2 a t2 y t3) z (Node2 a t4 u t5)))))))
(declare-fun node33 (par (a) ((tree23 a) a (tree23 a) a (upD a)) (upD a)))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a))) (= (node33 a t1 x t2 y (TD a t3))
  (TD a (Node3 a t1 x t2 y t3))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (t4 (tree23 a)))
  (= (node33 a t1 x (Node2 a t2 y t3) z (UF a t4)) (TD a (Node2 a t1 x (Node3 a t2 y t3 z t4)))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (t4 (tree23 a)) (u a) (t5 (tree23 a)))
  (= (node33 a t1 x (Node3 a t2 y t3 z t4) u (UF a t5)) (TD a (Node3 a t1 x (Node2 a t2 y t3) z (Node2 a t4 u t5)))))))
(declare-fun split_min23 (par (a) ((tree23 a)) (pair a (upD a))))
(assert (par (a) (forall ((x a)) (= (split_min23 a (Node2 a (Leaf23 a) x (Leaf23 a))) (Pair a (upD a) x (UF a (Leaf23 a)))))))
(assert (par (a) (forall ((x a) (y a)) (= (split_min23 a (Node3 a (Leaf23 a) x (Leaf23 a) y (Leaf23 a)))
  (Pair a (upD a) x (TD a (Node2 a (Leaf23 a) y (Leaf23 a))))))))
(assert (par (a) (forall ((l (tree23 a)) (x a) (r (tree23 a))) (=> (and (distinct l (Leaf23 a)) (distinct r (Leaf23 a)))
  (= (split_min23 a (Node2 a l x r))
    (let ((xl (split_min23 a l))) (Pair a (upD a) (Pair_0 a (upD a) (xl a)) (node21 a (Pair_1 a (upD a) (xl a)) x r))))))))
(assert (par (a) (forall ((l (tree23 a)) (x a) (m (tree23 a)) (y a) (r (tree23 a))) (=> (and (distinct l (Leaf23 a)) (distinct m (Leaf23 a)) (distinct r (Leaf23 a)))
  (= (split_min23 a (Node3 a l x m y r))
    (let ((xl (split_min23 a l))) (Pair a (upD a) (Pair_0 a (upD a) (xl a)) (node31 a (Pair_1 a (upD a) (xl a)) x m y r))))))))
(declare-fun del (par (a) (a (tree23 a)) (upD a)))
(assert (par (a) (forall ((x a)) (= (del a x (Leaf23 a)) (TD a (Leaf23 a))))))
(assert (par (a) (forall ((x a) (y a)) (= (del a x (Node2 a (Leaf23 a) y (Leaf23 a))) (ite (= x y) (UF a (Leaf23 a)) (TD a (Node2 a (Leaf23 a) y (Leaf23 a))))))))
(assert (par (a) (forall ((x a) (y a) (z a)) (= (del a x (Node3 a (Leaf23 a) y (Leaf23 a) z (Leaf23 a)))
  (TD a (ite (= x y) (Node2 a (Leaf23 a) z (Leaf23 a)) (ite (= x z) (Node2 a (Leaf23 a) y (Leaf23 a)) (Node3 a (Leaf23 a) y (Leaf23 a) z (Leaf23 a)))))))))
(assert (par (a) (forall ((x a) (l (tree23 a)) (y a) (r (tree23 a))) (=> (and (distinct l (Leaf23 a)) (distinct r (Leaf23 a))) (= (del a x (Node2 a l y r))
  (match (cmp a x y) ((LT (node21 a (del a x l) y r))
                      (EQ (let ((ar (split_min23 a r))) (node22 a l (Pair_0 a (upD a) (ar a)) (Pair_1 a (upD a) (ar a)))))
                      (GT (node22 a l y (del a x r))))))))))
(assert (par (a) (forall ((x a) (l (tree23 a)) (y a) (m (tree23 a)) (z a) (r (tree23 a))) (=> (and (distinct l (Leaf23 a)) (distinct m (Leaf23 a)) (distinct r (Leaf23 a)))
  (= (del a x (Node3 a l y m z r))
    (match (cmp a x y) ((LT (node31 a (del a x l) y m z r))
                        (EQ (let ((am (split_min23 a m))) (node32 a l (Pair_0 a (upD a) (am a)) (Pair_1 a (upD a) (am a)) z r)))
                        (GT (match (cmp a x z) ((LT (node32 a l y (del a x m) z r))
                                                (EQ (let ((br (split_min23 a r))) (node33 a l y m (Pair_0 a (upD a) (br a)) (Pair_1 a (upD a) (br a)))))
                                                (GT (node33 a l y m z (del a x r)))))))))))))
(declare-fun delete23 (par (a) (a (tree23 a)) (tree23 a)))
(assert (par (a) (forall ((x a) (t (tree23 a))) (= (delete23 a x t) (treeD a (del a x t))))))

(declare-fun len23s (par (a) ((tree23s a)) nat))
(assert (par (a) (forall ((t (tree23 a))) (= (len23s a (T a t)) (s zero)))))
(assert (par (a) (forall ((t (tree23 a)) (x a) (ts (tree23s a))) (= (len23s a (TTs a t x ts)) (s (len23s a ts))))))
;(declare-fun trees ((tree23s a)) set)
(declare-fun in_trees (par (a) ((tree23 a) (tree23s a)) Bool))
(assert (par (a) (forall ((s (tree23 a)) (t (tree23 a))) (= (in_trees a s (T a t)) (= s t)))))
(assert (par (a) (forall ((s (tree23 a)) (t (tree23 a)) (x a) (ts (tree23s a))) (= (in_trees a s (TTs a t x ts)) (or (= s t) (in_trees a s ts))))))
(declare-fun inorder23s (par (a) ((tree23s a)) (list a)))
(assert (par (a) (forall ((t (tree23 a))) (= (inorder23s a (T a t)) (inorder23 a t)))))
(assert (par (a) (forall ((t (tree23 a)) (x a) (ts (tree23s a))) (= (inorder23s a (TTs a t x ts)) (append a (inorder23 a t) (Cons a x (inorder23s a ts)))))))
(declare-fun join_adj (par (a) ((tree23s a)) (tree23s a)))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a))) (= (join_adj a (TTs a t1 x (T a t2))) (T a (Node2 a t1 x t2))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a))) (= (join_adj a (TTs a t1 x (TTs a t2 y (T a t3))))
  (T a (Node3 a t1 x t2 y t3))))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (ts (tree23s a))) (= (join_adj a (TTs a t1 x (TTs a t2 y (TTs a t3 z ts))))
  (TTs a (Node2 a t1 x t2) y (join_adj a (TTs a t3 z ts)))))))
(declare-fun join_all (par (a) ((tree23s a)) (tree23 a)))
(assert (par (a) (forall ((t (tree23 a))) (= (join_all a (T a t)) t))))
(assert (par (a) (forall ((x a) (t (tree23 a)) (ts (tree23s a))) (= (join_all a (TTs a t x ts)) (join_all a (join_adj a (TTs a t x ts)))))))
(declare-fun not_T (par (a) ((tree23s a)) Bool))
(assert (par (a) (forall ((ts (tree23s a))) (= (not_T a ts) (forall ((t (tree23 a))) (distinct ts (T a t)))))))
(declare-fun leaves (par (a) ((list a)) (tree23s a)))
(assert (par (a) (= (leaves a (Nil a)) (T a (Leaf23 a)))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (leaves a (Cons a x xs)) (TTs a (Leaf23 a) x (leaves a xs))))))
(declare-fun tree23_of_list (par (a) ((list a)) (tree23 a)))
(assert (par (a) (forall ((xs (list a))) (= (tree23_of_list a xs) (join_all a (leaves a xs))))))
(declare-fun T_join_adj (par (a) ((tree23s a)) nat))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a))) (= (T_join_adj a (TTs a t1 x (T a t2))) (s zero)))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a))) (= (T_join_adj a (TTs a t1 x (TTs a t2 y (T a t3)))) (s zero)))))
(assert (par (a) (forall ((t1 (tree23 a)) (x a) (t2 (tree23 a)) (y a) (t3 (tree23 a)) (z a) (ts (tree23s a)))
  (= (T_join_adj a (TTs a t1 x (TTs a t2 y (TTs a t3 z ts)))) (s (T_join_adj a ts))))))
(declare-fun T_join_all (par (a) ((tree23s a)) nat))
(assert (par (a) (forall ((t (tree23 a))) (= (T_join_all a (T a t)) (s zero)))))
(assert (par (a) (forall ((x a) (t (tree23 a)) (ts (tree23s a))) (= (T_join_all a (TTs a t x ts))
  (s (plus (T_join_adj a (TTs a t x ts)) (T_join_all a (join_adj a (TTs a t x ts)))))))))
(declare-fun T_leaves (par (a) ((list a)) nat))
(assert (par (a) (= (T_leaves a (Nil a)) (s zero))))
(assert (par (a) (forall ((x a) (xs (list a))) (= (T_leaves a (Cons a x xs)) (s (T_leaves a xs))))))
(declare-fun T_tree23_of_list (par (a) ((list a)) nat))
(assert (par (a) (forall ((xs (list a))) (= (T_tree23_of_list a xs) (s (plus (T_leaves a xs) (T_join_all a (leaves a xs))))))))

; red-black trees
(declare-fun R (par (a) ((rbt a) a (rbt a)) (rbt a)))
(assert (par (a) (forall ((l (rbt a)) (x a) (r (rbt a))) (= (R a l x r) (NodeP a color l x Red r)))))
(declare-fun B (par (a) ((rbt a) a (rbt a)) (rbt a)))
(assert (par (a) (forall ((l (rbt a)) (x a) (r (rbt a))) (= (B a l x r) (NodeP a color l x Black r)))))
(declare-fun color_of (par (a) ((rbt a)) color))
(assert (par (a) (= (color_of a (LeafP a color)) Black)))
(assert (par (a) (forall ((l (rbt a)) (x a) (c color) (r (rbt a))) (= (color_of a (NodeP a color l x c r)) c))))
(declare-fun paint (par (a) (color (rbt a)) (rbt a)))
(assert (par (a) (forall ((c color)) (= (paint a c (LeafP a color)) (LeafP a color)))))
(assert (par (a) (forall ((c color) (l (rbt a)) (x a) (d color) (r (rbt a))) (= (paint a c (NodeP a color l x d r)) (NodeP a color l x c r)))))
(declare-fun invc (par (a) ((rbt a)) Bool))
(assert (par (a) (invc a (LeafP a color))))
(assert (par (a) (forall ((l (rbt a)) (x a) (c color) (r (rbt a))) (= (invc a (NodeP a color l x c r))
  (and (=> (= c Red) (and (= (color_of a l) Black) (= (color_of a r) Black))) (invc a l) (invc a r))))))
(declare-fun bh (par (a) ((rbt a)) nat))
(assert (par (a) (= (bh a (LeafP a color)) zero)))
(assert (par (a) (forall ((l (rbt a)) (x a) (c color) (r (rbt a))) (= (bh a (NodeP a color l x c r))
  (ite (= c Black) (s (bh a l)) (bh a l))))))
(declare-fun invh (par (a) ((rbt a)) Bool))
(assert (par (a) (invh a (LeafP a color))))
(assert (par (a) (forall ((l (rbt a)) (x a) (c color) (r (rbt a))) (= (invh a (NodeP a color l x c r))
  (and (= (bh a l) (bh a r)) (invh a l) (invh a r))))))
(declare-fun inv_rbt (par (a) ((rbt a)) Bool))
(assert (par (a) (forall ((t (rbt a))) (= (inv_rbt a t) (and (invc a t) (invh a t) (= (color_of a t) Black))))))
(declare-fun baliL (par (a) ((rbt a) a (rbt a)) (rbt a)))
(assert (par (a) (forall ((l (rbt a)) (t1 (rbt a)) (x a) (t2 (rbt a)) (y a) (t3 (rbt a)) (z a) (t4 (rbt a)))
  (= (baliL a l z t4) (ite (or (= l (R a (R a t1 x t2) y t3)) (= l (R a t1 x (R a t2 y t3))))
    (R a (B a t1 x t2) y (B a t3 z t4)) (B a l z t4))))))
(declare-fun baliR (par (a) ((rbt a) a (rbt a)) (rbt a)))
(assert (par (a) (forall ((t1 (rbt a)) (x a) (t2 (rbt a)) (y a) (t3 (rbt a)) (z a) (t4 (rbt a)) (r (rbt a)))
  (= (baliR a t1 x r) (ite (or (= r (R a t2 y (R a t3 z t4))) (= r (R a (R a t2 y t3) z t4)))
    (R a (B a t1 x t2) y (B a t3 z t4)) (B a t1 x r))))))
(declare-fun insRB (par (a) (a (rbt a)) (rbt a)))
(assert (par (a) (forall ((x a)) (= (insRB a x (LeafP a color)) (R a (LeafP a color) x (LeafP a color))))))
(assert (par (a) (forall ((x a) (l (rbt a)) (y a) (r (rbt a))) (= (insRB a x (B a l y r))
  (match (cmp a x y) ((LT (baliL a (insRB a x l) y r))
                      (EQ (B a l y r))
                      (GT (baliR a l y (insRB a x r)))))))))
(assert (par (a) (forall ((x a) (l (rbt a)) (y a) (r (rbt a))) (= (insRB a x (R a l y r))
  (match (cmp a x y) ((LT (R a (insRB a x l) y r))
                      (EQ (R a l y r))
                      (GT (R a l y (insRB a x r)))))))))
(declare-fun insertRB (par (a) (a (rbt a)) (rbt a)))
(assert (par (a) (forall ((x a) (t (rbt a))) (= (insertRB a x t) (paint a Black (insRB a x t))))))
(declare-fun invc2 (par (a) ((rbt a)) Bool))
(assert (par (a) (forall ((t (rbt a))) (= (invc2 a t) (invc a (paint a Black t))))))

(declare-fun baldL (par (a) ((rbt a) a (rbt a)) (rbt a)))
(assert (par (a) (forall ((l (rbt a)) (x a) (r (rbt a)) (l1 (rbt a)) (l2 (rbt a)) (r1 (rbt a)) (r2 (rbt a)) (r3 (rbt a)) (r4 (rbt a)) (r5 (rbt a)) (xl a) (xr1 a) (xr2 a) (xr3 a))
  (= (baldL a l x r) (ite (= l (R a l1 xl l2)) (R a (B a l1 xl l2) x r)
    (ite (= r (B a r1 xr1 r2)) (baliR a l x (R a r1 xr1 r2)) (ite (= r (R a (B a r3 xr2 r4) xr3 r5))
      (R a (B a l x r3) xr2 (baliR a r4 xr3 (paint a Red r5))) (R a l x r))))))))
(declare-fun baldR (par (a) ((rbt a) a (rbt a)) (rbt a)))
(assert (par (a) (forall ((l (rbt a)) (x a) (r (rbt a)) (r1 (rbt a)) (r2 (rbt a)) (l1 (rbt a)) (l2 (rbt a)) (l3 (rbt a)) (l4 (rbt a)) (l5 (rbt a)) (xr a) (xl1 a) (xl2 a) (xl3 a))
  (= (baldR a l x r) (ite (= r (R a r1 xr r2)) (R a l x (B a r1 xr r2))
    (ite (= l (B a l1 xl1 l2)) (baliL a (R a l1 xl1 l2) x r) (ite (= l (R a l3 xl2 (B a l4 xl3 l5)))
      (R a (baliL a (paint a Red l3) xl2 l4) xl3 (B a l5 x r)) (R a l x r))))))))
(declare-fun split_minRB (par (a) ((rbt a)) (pair a (rbt a))))
(assert (par (a) (forall ((l (rbt a)) (x a) (c color) (r (rbt a))) (= (split_minRB a (NodeP a color l x c r))
  (ite (= l (LeafP a color)) (Pair a (rbt a) x r) (let ((xl (split_minRB a l)))
    (Pair a (rbt a) (Pair_0 a (rbt a) (xl a)) (ite (= (color_of a l) Black) (baldL a (Pair_1 a (rbt a) (xl a)) x r) (R a (Pair_1 a (rbt a) (xl a)) x r)))))))))
(declare-fun delRB (par (a) (a (rbt a)) (rbt a)))
(assert (par (a) (forall ((x a) (l (rbt a)) (y a) (c color) (r (rbt a))) (= (delRB a x (NodeP a color l y c r))
  (match (cmp a x y) ((LT (let ((ll (delRB a x l))) (ite (and (distinct l (LeafP a color)) (= (color_of a l) Black)) (baldL a (ll a) y r) (R a (ll a) y r))))
                      (EQ (ite (= r (LeafP a color)) l (let ((ar (split_minRB a r))) (ite (= (color_of a r) Black)
                        (baldR a l (Pair_0 a (rbt a) (ar a)) (Pair_1 a (rbt a) (ar a))) (R a l (Pair_0 a (rbt a) (ar a)) (Pair_1 a (rbt a) (ar a)))))))
                      (GT (let ((rr (delRB a x r))) (ite (and (distinct r (LeafP a color)) (= (color_of a r) Black)) (baldR a l y (rr a)) (R a l y (rr a)))))))))))

(declare-fun deleteRB (par (a) (a (rbt a)) (rbt a)))
(assert (par (a) (forall ((x a) (t (rbt a))) (= (deleteRB a x t) (paint a Black (delRB a x t))))))
;(declare-fun bhs ((rbt a)) set)
(declare-fun joinRB (par (a) ((rbt a) (rbt a)) (rbt a)))
; TODO not well-defined
;(assert (par (a) (forall ((t (rbt a))) (= (joinRB a t (LeafP a color)) t))))
;(assert (par (a) (forall ((t (rbt a))) (= (joinRB a (LeafP a color) t) t))))
;(assert (forall ((t1 (rbt a)) (x a) (t2 (rbt a)) (t3 (rbt a)) (c a) (t4 (rbt a))) (= (joinRB (R t1 a t2) (R t3 c t4))
;  (match (joinRB t2 t3) (((R u2 b u3) (R (R t1 a u2) b (R u3 c t4)))
;                         (t23 (R t1 a (R t23 c t4))))))))
;(assert (forall ((t1 (rbt a)) (x a) (t2 (rbt a)) (t3 (rbt a)) (c a) (t4 (rbt a))) (= (joinRB (B t1 a t2) (B t3 c t4))
;  (match (joinRB t2 t3) (((R u2 b u3) (R (B t1 a u2) b (B u3 c t4)))
;                         (t23 (baldL t1 a (R t23 c t4))))))))
;(assert (par (a) (forall ((t1 (rbt a)) (x a) (t2 (rbt a)) (t3 (rbt a))) (= (joinRB a t1 (R a t2 x t3)) (R a (joinRB a t1 t2) x t3)))))
;(assert (par (a) (forall ((t1 (rbt a)) (x a) (t2 (rbt a)) (t3 (rbt a))) (= (joinRB a (R a t1 x t2) t3) (R a t1 x (joinRB a t2 t3))))))
(declare-fun delRB2 (par (a) (a (rbt a)) (rbt a)))
(assert (par (a) (forall ((x a) (l (rbt a)) (y a) (c color) (r (rbt a))) (= (delRB2 a x (NodeP a color l y c r))
  (match (cmp a x y) ((LT (let ((ll (delRB2 a x l))) (ite (and (distinct l (LeafP a color)) (= (color_of a l) Black)) (baldL a (ll a) y r) (R a (ll a) y r))))
                      (EQ (joinRB a l r))
                      (GT (let ((rr (delRB2 a x r))) (ite (and (distinct r (LeafP a color)) (= (color_of a r) Black)) (baldR a l y (rr a)) (R a l y (rr a)))))))))))
; TODO define this
;(declare-fun rbt_of_list (par (a) ((list a)) (rbt a)))
;(assert (par (a) (forall ((xs (list a))) (= (rbt_of_list a xs) (join_all a (leaves a xs))))))

; AVL trees
(declare-fun ht (par (a) ((tree_ht a)) nat))
(assert (par (a) (= (ht a (LeafP a nat)) zero)))
(assert (par (a) (forall ((l (tree_ht a)) (x a) (n nat) (r (tree_ht a))) (= (ht a (NodeP a nat l x n r)) n))))
(declare-fun node (par (a) ((tree_ht a) a (tree_ht a)) (tree_ht a)))
(assert (par (a) (forall ((l (tree_ht a)) (x a) (r (tree_ht a))) (= (node a l x r) (NodeP a nat l x (s (max nat(ht a l) (ht a r))) r)))))
(declare-fun avl (par (a) ((tree_ht a)) Bool))
(assert (par (a) (avl a (LeafP a nat))))
(assert (par (a) (forall ((l (tree_ht a)) (x a) (n nat) (r (tree_ht a))) (= (avl a (NodeP a nat l x n r))
  (let ((hl (h (pair a nat) l)) (hr (h (pair a nat) r))) (and (or (= hl hr) (= (s hl) hr) (= hl (s hr))) (= n (s (max nat hl hr))) (avl a l) (avl a r)))))))
(declare-fun balL (par (a) ((tree_ht a) a (tree_ht a)) (tree_ht a)))
(assert (par (a) (forall ((XY (tree_ht a)) (z a) (Z (tree_ht a))) (= (balL a XY z Z) (ite (= (ht a XY) (s (s (ht a Z))))
  (match XY (((Node (pair a nat) X x Y) (ite (leq nat (ht a Y) (ht a X)) (node a X (Pair_0 a nat x) (node a Y z Z))
                (match Y (((Node (pair a nat) Y1 y Y2) (node a (node a X (Pair_0 a nat x) Y1) (Pair_0 a nat y) (node a Y2 z Z)))
                          ((Leaf (pair a nat)) (node a XY z Z))))))
             ((Leaf (pair a nat)) (node a XY z Z)))) (node a XY z Z))))))
(declare-fun balR (par (a) ((tree_ht a) a (tree_ht a)) (tree_ht a)))
(assert (par (a) (forall ((X (tree_ht a)) (x a) (YZ (tree_ht a))) (= (balR a X x YZ) (ite (= (ht a YZ) (s (s (ht a X))))
  (match YZ (((Node (pair a nat) Y y Z) (ite (leq nat (ht a Y) (ht a Z)) (node a (node a X x Y) (Pair_0 a nat y) Z)
                (match Y (((Node (pair a nat) Y1 z Y2) (node a (node a X x Y1) (Pair_0 a nat z) (node a Y2 (Pair_0 a nat y) Z)))
                          (_ (node a X x YZ))))))
             (_ (node a X x YZ)))) (node a X x YZ))))))
(declare-fun insertAVL (par (a) (a (tree_ht a)) (tree_ht a)))
(assert (par (a) (forall ((x a)) (= (insertAVL a x (LeafP a nat)) (NodeP a nat (LeafP a nat) x (s zero) (LeafP a nat))))))
(assert (par (a) (forall ((x a) (l (tree_ht a)) (y a) (n nat) (r (tree_ht a))) (= (insertAVL a x (NodeP a nat l y n r))
  (match (cmp a x y) ((LT (balL a (insertAVL a x l) y r))
                      (EQ (NodeP a nat l y n r))
                      (GT (balR a l y (insertAVL a x r)))))))))
(declare-fun split_max (par (a) ((tree_ht a)) (pair (tree_ht a) a)))
(assert (par (a) (forall ((l (tree_ht a)) (x a) (n nat) (r (tree_ht a))) (= (split_max a (NodeP a nat l x n r))
  (ite (= r (LeafP a nat)) (Pair (tree_ht a) a l x) (let ((rx (split_max a r))) (Pair (tree_ht a) a (balL a l x (Pair_0 (tree_ht a) a (rx a))) (Pair_1 (tree_ht a) a (rx a)))))))))
(declare-fun deleteAVL (par (a) (a (tree_ht a)) (tree_ht a)))
(assert (par (a) (forall ((x a)) (= (deleteAVL a x (LeafP a nat)) (LeafP a nat)))))
(assert (par (a) (forall ((x a) (l (tree_ht a)) (y a) (n nat) (r (tree_ht a))) (= (deleteAVL a x (NodeP a nat l y n r))
  (match (cmp a x y) ((LT (balR a (deleteAVL a x l) y r))
                      (EQ (ite (= l (LeafP a nat)) r (let ((ly (split_max a l))) (balR a (Pair_0 (tree_ht a) a (ly a)) (Pair_1 (tree_ht a) a (ly a)) r))))
                      (GT (balL a l y (deleteAVL a x r)))))))))
(declare-fun fibt (nat) (tree unit))
(assert (= (fibt zero) (Leaf unit)))
(assert (= (fibt (s zero)) (Node unit (Leaf unit) Unit (Leaf unit))))
(assert (forall ((n nat)) (= (fibt (s (s n))) (Node unit (fibt (s n)) Unit (fibt n)))))
(declare-fun avl0 (par (a) ((tree a)) Bool))
(assert (par (a) (avl0 a (Leaf a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (avl0 a (Node a l x r)) (and (avl0 a l) (avl0 a r)
  (or (= (s (h a l)) (h a r)) (= (h a l) (h a r)) (= (h a l) (s (h a r)))))))))
(declare-fun avl_bal (par (a) ((tree_bal a)) Bool))
(assert (par (a) (avl_bal a (LeafP a bal))))
(assert (par (a) (forall ((l (tree_bal a)) (x a) (b bal) (r (tree_bal a))) (= (avl_bal a (NodeP a bal l x b r))
  (and (match b ((Lh (= (h (pair a bal) l) (s (h (pair a bal) r))))
                 (Bal (= (h (pair a bal) l) (h (pair a bal) r)))
                 (Rh (= (s (h (pair a bal) l)) (h (pair a bal) r)))))
    (avl_bal a l) (avl_bal a r))))))
(declare-fun is_bal (par (a) ((tree_bal a)) Bool))
(assert (par (a) (forall ((l (tree_bal a)) (x a) (b bal) (r (tree_bal a))) (= (is_bal a (NodeP a bal l x b r)) (= b Bal)))))
(declare-fun incr (par (a b) ((tree_bal a) (tree_bal b)) Bool))
(assert (par (a b) (forall ((t (tree_bal a)) (t' (tree_bal b))) (= (incr a b t t')
  (or (= t (LeafP a bal)) (and (is_bal a t) (not (is_bal b t'))))))))
(declare-fun decr (par (a b) ((tree_bal a) (tree_bal b)) Bool))
(assert (par (a b) (forall ((t (tree_bal a)) (t' (tree_bal b))) (= (decr a b t t') (and (distinct t (LeafP a bal))
  (or (= t' (LeafP b bal)) (and (not (is_bal a t)) (is_bal b t'))))))))
(declare-fun rot2 (par (a) ((tree_bal a) a (tree_bal a) a (tree_bal a)) (tree_bal a)))
(assert (par (a) (forall ((A (tree_bal a)) (x a) (B1 (tree_bal a)) (y a) (b bal) (B2 (tree_bal a)) (z a) (C (tree_bal a)))
  (= (rot2 a A x (NodeP a bal B1 y b B2) z C) (let ((b1 (ite (= b Rh) Lh Bal)) (b2 (ite (= b Lh) Rh Bal)))
    (NodeP a bal (NodeP a bal A x b1 B1) y Bal (NodeP a bal B2 z b2 C)))))))
(declare-fun balL_bal (par (a) ((tree_bal a) a bal (tree_bal a)) (tree_bal a)))
(assert (par (a) (forall ((X (tree_bal a)) (x a) (b bal) (Y (tree_bal a)) (y a) (Z (tree_bal a)))
  (= (balL_bal a (NodeP a bal X x b Y) y Lh Z) (match b
    ((Lh (NodeP a bal X x Bal (NodeP a bal Y y Bal Z)))
     (Bal (NodeP a bal X x Rh (NodeP a bal Y y Lh Z)))
     (Rh (rot2 a X x Y y Z))))))))
(assert (par (a) (forall ((AB (tree_bal a)) (c a) (C (tree_bal a))) (= (balL_bal a AB c Bal C) (NodeP a bal AB c Lh C)))))
(assert (par (a) (forall ((AB (tree_bal a)) (c a) (C (tree_bal a))) (= (balL_bal a AB c Rh C) (NodeP a bal AB c Bal C)))))
(declare-fun balR_bal (par (a) ((tree_bal a) a bal (tree_bal a)) (tree_bal a)))
(assert (par (a) (forall ((X (tree_bal a)) (x a) (b bal) (Y (tree_bal a)) (y a) (Z (tree_bal a)))
  (= (balR_bal a X x Rh (NodeP a bal Y y b Z)) (match b
    ((Lh (rot2 a X x Y y Z))
     (Bal (NodeP a bal (NodeP a bal X x Rh Y) y Lh Z))
     (Rh (NodeP a bal (NodeP a bal X x Bal Y) y Bal Z))))))))
(assert (par (a) (forall ((AB (tree_bal a)) (c a) (C (tree_bal a))) (= (balL_bal a AB c Bal C) (NodeP a bal AB c Lh C)))))
(assert (par (a) (forall ((AB (tree_bal a)) (c a) (C (tree_bal a))) (= (balL_bal a AB c Rh C) (NodeP a bal AB c Bal C)))))
(declare-fun insert_bal (par (a) (a (tree_bal a)) (tree_bal a)))
(assert (par (a) (forall ((x a)) (= (insert_bal a x (LeafP a bal)) (NodeP a bal (LeafP a bal) x Bal (LeafP a bal))))))
(assert (par (a) (forall ((x a) (l (tree_bal a)) (y a) (b bal) (r (tree_bal a))) (= (insert_bal a x (NodeP a bal l y b r))
  (match (cmp a x y) ((LT (let ((l' (insert_bal a x l))) (ite (incr a a l (l' a)) (balL_bal a (l' a) y b r) (NodeP a bal (l' a) y b r))))
                      (EQ (NodeP a bal l y b r))
                      (GT (let ((r' (insert_bal a x r))) (ite (incr a a r (r' a)) (balR_bal a l y b (r' a)) (NodeP a bal l y b (r' a)))))))))))
(declare-fun split_max_bal (par (a) ((tree_bal a)) (pair (tree_bal a) a)))
(assert (par (a) (forall ((l (tree_bal a)) (x a) (b bal) (r (tree_bal a))) (= (split_max_bal a (NodeP a bal l x b r))
  (ite (= r (LeafP a bal)) (Pair (tree_bal a) a l x) (let ((rx (split_max_bal a r)))
    (let ((t (ite (decr a a r (Pair_0 (tree_bal a) a (rx a))) (balL_bal a l x b (Pair_0 (tree_bal a) a (rx a)))
      (NodeP a bal l x b (Pair_0 (tree_bal a) a (rx a)))))) (Pair (tree_bal a) a (t a) (Pair_1 (tree_bal a) a (rx a))))))))))
(declare-fun delete_bal (par (a) (a (tree_bal a)) (tree_bal a)))
(assert (par (a) (forall ((x a)) (= (delete_bal a x (LeafP a bal)) (LeafP a bal)))))
(assert (par (a) (forall ((x a) (l (tree_bal a)) (y a) (b bal) (r (tree_bal a))) (= (delete_bal a x (NodeP a bal l y b r))
  (match (cmp a x y) ((LT (let ((l' (delete_bal a x l))) (ite (decr a a l (l' a)) (balR_bal a (l' a) y b r) (NodeP a bal (l' a) y b r))))
                      (EQ (ite (= l (LeafP a bal)) r (let ((ly (split_max_bal a l))) (ite (decr a a l (Pair_0 (tree_bal a) a (ly a)))
                        (balR_bal a (Pair_0 (tree_bal a) a (ly a)) (Pair_1 (tree_bal a) a (ly a)) b r)
                        (NodeP a bal (Pair_0 (tree_bal a) a (ly a)) (Pair_1 (tree_bal a) a (ly a)) b r)))))
                      (GT (let ((r' (delete_bal a x r))) (ite (decr a a r (r' a)) (balL_bal a l y b (r' a)) (NodeP a bal l y b (r' a)))))))))))
(declare-fun debal (par (a) ((tree_bal a)) (tree_ht a)))
(assert (par (a) (= (debal a (LeafP a bal)) (LeafP a nat))))
(assert (par (a) (forall ((l (tree_bal a)) (x a) (b bal) (r (tree_bal a))) (= (debal a (NodeP a bal l x b r))
  (NodeP a nat (debal a l) x (s (max nat (h (pair a bal) l) (h (pair a bal) r))) (debal a r))))))
; TODO define this
(declare-fun debal2 (par (a) ((tree_bal a)) (tree_ht a)))

; these are supposed to be uninterpreted and defined by their specification below
(declare-fun joinp (par (a b) ((ptree a b) a (ptree a b)) (ptree a b)))
(declare-fun invp (par (a b) ((ptree a b)) Bool))
(assert (par (a b) (forall ((l (ptree a b)) (x a) (r (ptree a b)) (y a)) (= (in_set_ptree a b y (joinp a b l x r))
  (or (in_set_ptree a b y l) (= x y) (in_set_ptree a b y r))))))
(assert (par (a b) (forall ((l (ptree a b)) (x a) (y b) (r (ptree a b)))
  (=> (bst (pair a b) (NodeP a b l x y r)) (bst (pair a b) (joinp a b l x r))))))
(assert (par (a b) (invp a b (LeafP a b))))
(assert (par (a b) (forall ((l (ptree a b)) (x a) (r (ptree a b)))
  (=> (and (invp a b l) (invp a b r)) (invp a b (joinp a b l x r))))))
(assert (par (a b) (forall ((l (ptree a b)) (x a) (y b) (r (ptree a b)))
  (=> (invp a b (NodeP a b l x y r)) (and (invp a b l) (invp a b r))))))

(declare-fun split_minp (par (a b) ((ptree a b)) (pair a (ptree a b))))
(assert (par (a b) (forall ((l (ptree a b)) (x a) (y b) (r (ptree a b))) (= (split_minp a b (NodeP a b l x y r))
  (ite (= l (LeafP a b)) (Pair a (ptree a b) x r) (let ((xl (split_minp a b l))) (Pair a (ptree a b) (Pair_0 a (ptree a b) (xl a b)) (joinp a b (Pair_1 a (ptree a b) (xl a b)) x r))))))))
(declare-fun join2 (par (a b) ((ptree a b) (ptree a b)) (ptree a b)))
(assert (par (a b) (forall ((l (ptree a b)) (r (ptree a b))) (= (join2 a b l r) (ite (= r (LeafP a b))
  l (let ((mr (split_minp a b r))) (joinp a b l (Pair_0 a (ptree a b) (mr a b)) (Pair_1 a (ptree a b) (mr a b)))))))))
(declare-fun splitp (par (a b) ((ptree a b) a) (triple (ptree a b) Bool (ptree a b))))
(assert (par (a b) (forall ((x a)) (= (splitp a b (LeafP a b) x) (Triple (ptree a b) Bool (ptree a b) (LeafP a b) false (LeafP a b))))))
(assert (par (a b) (forall ((l (ptree a b)) (y a) (z b) (r (ptree a b)) (x a)) (= (splitp a b (NodeP a b l y z r) x)
  (match (cmp a x y) ((LT (let ((t (splitp a b l x))) (Triple (ptree a b) Bool (ptree a b) (Triple_0 (ptree a b) Bool (ptree a b) (t a b)) (Triple_1 (ptree a b) Bool (ptree a b) (t a b))
                        (joinp a b (Triple_2 (ptree a b) Bool (ptree a b) (t a b)) y r))))
                      (EQ (Triple (ptree a b) Bool (ptree a b) l true r))
                      (GT (let ((t (splitp a b r x))) (Triple (ptree a b) Bool (ptree a b) (joinp a b l y (Triple_0 (ptree a b) Bool (ptree a b) (t a b)))
                        (Triple_1 (ptree a b) Bool (ptree a b) (t a b)) (Triple_2 (ptree a b) Bool (ptree a b) (t a b)))))))))))
(declare-fun union (par (a b) ((ptree a b) (ptree a b)) (ptree a b)))
(assert (par (a b) (forall ((t (ptree a b))) (= (union a b (LeafP a b) t) t))))
(assert (par (a b) (forall ((t (ptree a b))) (= (union a b t (LeafP a b)) t))))
(assert (par (a b) (forall ((l1 (ptree a b)) (x a) (y b) (r1 (ptree a b)) (t (ptree a b))) (=> (distinct t (LeafP a b)) (= (union a b (NodeP a b l1 x y r1) t)
  (let ((t' (splitp a b t x))) (joinp a b (union a b l1 (Triple_0 (ptree a b) Bool (ptree a b) (t' a b))) x (union a b r1 (Triple_2 (ptree a b) Bool (ptree a b) (t' a b))))))))))
(declare-fun inter (par (a b) ((ptree a b) (ptree a b)) (ptree a b)))
(assert (par (a b) (forall ((t (ptree a b))) (= (inter a b (LeafP a b) t) (LeafP a b)))))
(assert (par (a b) (forall ((t (ptree a b))) (= (inter a b t (LeafP a b)) (LeafP a b)))))
(assert (par (a b) (forall ((l1 (ptree a b)) (x a) (y b) (r1 (ptree a b)) (t (ptree a b))) (=> (distinct t (LeafP a b)) (= (inter a b (NodeP a b l1 x y r1) t)
  (let ((t' (splitp a b t x))) (let ((l' (inter a b l1 (Triple_0 (ptree a b) Bool (ptree a b) (t' a b))))
    (r' (inter a b r1 (Triple_2 (ptree a b) Bool (ptree a b) (t' a b)))))
      (ite (Triple_1 (ptree a b) Bool (ptree a b) (t' a b)) (joinp a b (l' a b) x (r' a b)) (join2 a b (l' a b) (r' a b))))))))))
(declare-fun diff (par (a b) ((ptree a b) (ptree a b)) (ptree a b)))
(assert (par (a b) (forall ((t (ptree a b))) (= (diff a b (LeafP a b) t) (LeafP a b)))))
(assert (par (a b) (forall ((t (ptree a b))) (= (diff a b t (LeafP a b)) t))))
(assert (par (a b) (forall ((l2 (ptree a b)) (x a) (y b) (r2 (ptree a b)) (t (ptree a b))) (=> (distinct t (LeafP a b)) (= (diff a b t (NodeP a b l2 x y r2))
  (let ((t' (splitp a b t x))) (join2 a b (diff a b (Triple_0 (ptree a b) Bool (ptree a b) (t' a b)) l2) (diff a b (Triple_2 (ptree a b) Bool (ptree a b) (t' a b)) r2))))))))
(declare-fun joinL (par (a) ((rbt a) a (rbt a)) (rbt a)))
; TODO define this
;(assert (par (a) (forall ((l (rbt a)) (x a) (r (rbt a))) (= (joinL a l x r) (ite (leq a (bh a r) (bh a l)) (R a l x r)
;  (match r (())))))))
(declare-fun diff1 (par (a b) ((ptree a b) (ptree a b)) (ptree a b)))
; TODO define this

; Braun trees
(declare-fun braun (par (a) ((tree a)) Bool))
(assert (par (a) (braun a (Leaf a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (braun a (Node a l x r))
  (and (or (= (size a l) (size a r)) (= (size a l) (s (size a r)))) (braun a l) (braun a r))))))
(declare-fun splice (par (a) ((list a) (list a)) (list a)))
(assert (par (a) (forall ((ys (list a))) (= (splice a (Nil a) ys) ys))))
(assert (par (a) (forall ((x a) (xs (list a)) (ys (list a))) (= (splice a (Cons a x xs) ys)
  (Cons a x (splice a ys xs))))))
(declare-fun list_of (par (a) ((tree a)) (list a)))
(assert (par (a) (= (list_of a (Leaf a)) (Nil a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (list_of a (Node a l x r))
  (Cons a x (splice a (list_of a l) (list_of a r)))))))
(declare-fun lookup1 (par (a) ((tree a) nat) a))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a)) (n nat)) (= (lookup1 a (Node a l x r) n)
  (ite (= n (s zero)) x (lookup1 a (ite (even n) l r) (div2 n)))))))
(declare-fun update1 (par (a) (nat a (tree a)) (tree a)))
(assert (par (a) (forall ((n nat) (x a)) (= (update1 a n x (Leaf a)) (Node a (Leaf a) x (Leaf a))))))
(assert (par (a) (forall ((n nat) (x a) (l (tree a)) (y a) (r (tree a))) (= (update1 a n x (Node a l y r))
  (ite (= n (s zero)) (Node a l x r) (ite (even n) (Node a (update1 a (div2 n) x l) y r)
    (Node a l y (update1 a (div2 n) x r))))))))
(declare-fun adds (par (a) ((list a) nat (tree a)) (tree a)))
(assert (par (a) (forall ((n nat) (t (tree a))) (= (adds a (Nil a) n t) t))))
(assert (par (a) (forall ((x a) (xs (list a)) (n nat) (t (tree a))) (= (adds a (Cons a x xs) n t)
  (adds a xs (s n) (update1 a (s n) x t))))))
(declare-fun del_hi (par (a) (nat (tree a)) (tree a)))
(assert (par (a) (forall ((n nat)) (= (del_hi a n (Leaf a)) (Leaf a)))))
(assert (par (a) (forall ((n nat) (l (tree a)) (x a) (r (tree a))) (= (del_hi a n (Node a l x r))
  (ite (= n (s zero)) (Leaf a) (ite (even n) (Node a (del_hi a (div2 n) l) x r) (Node a l x (del_hi a (div2 n) r))))))))
(declare-fun add_lo (par (a) (a (tree a)) (tree a)))
(assert (par (a) (forall ((x a)) (= (add_lo a x (Leaf a)) (Node a (Leaf a) x (Leaf a))))))
(assert (par (a) (forall ((x a) (l (tree a)) (y a) (r (tree a))) (= (add_lo a x (Node a l y r))
  (Node a (add_lo a y r) x l)))))
(declare-fun merge_braun (par (a) ((tree a) (tree a)) (tree a)))
(assert (par (a) (forall ((r (tree a))) (= (merge_braun a (Leaf a) r) r))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a)) (rr (tree a))) (= (merge_braun a (Node a l x r) rr)
  (Node a rr x (merge_braun a l r))))))
(declare-fun del_lo (par (a) ((tree a)) (tree a)))
(assert (par (a) (= (del_lo a (Leaf a)) (Leaf a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (del_lo a (Node a l x r)) (merge_braun a l r)))))
(declare-fun diff_braun (par (a) ((tree a) nat) nat))
(assert (par (a) (forall ((n nat)) (= (diff_braun a (Leaf a) n) zero))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a)) (n nat)) (= (diff_braun a (Node a l x r) n)
  (ite (= n zero) (s zero) (ite (even n) (diff_braun a r (s_0 (div2 n))) (diff_braun a l (div2 n))))))))
(declare-fun size_fast (par (a) ((tree a)) nat))
(assert (par (a) (= (size_fast a (Leaf a)) zero)))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (size_fast a (Node a l x r))
  (let ((n (size_fast a r))) (s (plus (mult (s (s zero)) n) (diff_braun a l n))))))))
(declare-fun braun2_of (par (a) (a nat) (pair (tree a) (tree a))))
(assert (par (a) (forall ((x a) (n nat)) (= (braun2_of a x n)
  (ite (= n zero) (Pair (tree a) (tree a) (Leaf a) (Node a (Leaf a) x (Leaf a)))
    (let ((st (braun2_of a x (div2 (s_0 n))))) (ite (odd n)
      (Pair (tree a) (tree a) (Node a (Pair_0 (tree a) (tree a) (st a)) x (Pair_0 (tree a) (tree a) (st a)))
                              (Node a (Pair_1 (tree a) (tree a) (st a)) x (Pair_0 (tree a) (tree a) (st a))))
      (Pair (tree a) (tree a) (Node a (Pair_1 (tree a) (tree a) (st a)) x (Pair_0 (tree a) (tree a) (st a)))
                              (Node a (Pair_1 (tree a) (tree a) (st a)) x (Pair_1 (tree a) (tree a) (st a)))))))))))
(declare-fun braun_of (par (a) (a nat) (tree a)))
(assert (par (a) (forall ((x a) (n nat)) (= (braun_of a x n) (Pair_0 (tree a) (tree a) (braun2_of a x n))))))
(declare-fun take_nths (par (a) (nat nat (list a)) (list a)))
(assert (par (a) (forall ((i nat) (k nat)) (= (take_nths a i k (Nil a)) (Nil a)))))
(assert (par (a) (forall ((i nat) (k nat) (x a) (xs (list a))) (= (take_nths a i k (Cons a x xs))
  (ite (= i zero) (Cons a x (take_nths a (s_0 (pow2 k)) k xs)) (take_nths a (s_0 i) k xs))))))
(declare-fun braun_list (par (a) ((tree a) (list a)) Bool))
(assert (par (a) (forall ((xs (list a))) (= (braun_list a (Leaf a) xs) (= xs (Nil a))))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a)) (xs (list a))) (= (braun_list a (Node a l x r) xs)
  (and (distinct xs (Nil a)) (= x (hd a xs)) (braun_list a l (take_nths a (s zero) (s zero) xs))
    (braun_list a r (take_nths a (s (s zero)) (s zero) xs)))))))
(declare-fun nodes (par (a) ((list (tree a)) (list a) (list (tree a))) (list (tree a))))
(assert (par (a) (forall ((ls (list (tree a))) (xs (list a)) (rs (list (tree a)))) (= (nodes a ls xs rs)
  (match xs (((Nil a) (Nil (tree a)))
             ((Cons a x xs0) (match ls
                (((Nil (tree a)) (match rs
                   (((Nil (tree a)) (Cons (tree a) (Node a (Leaf a) x (Leaf a)) (nodes a (Nil (tree a)) xs0 (Nil (tree a)))))
                    ((Cons (tree a) r rs0) (Cons (tree a) (Node a (Leaf a) x r) (nodes a (Nil (tree a)) xs0 rs0))))))
                 ((Cons (tree a) l ls0) (match rs
                   (((Nil (tree a)) (Cons (tree a) (Node a l x (Leaf a)) (nodes a ls0 xs0 (Nil (tree a)))))
                    ((Cons (tree a) r rs0) (Cons (tree a) (Node a l x r) (nodes a ls0 xs0 rs0)))))))))))))))
(declare-fun brauns (par (a) (nat (list a)) (list (tree a))))
(assert (par (a) (forall ((k nat) (xs (list a))) (= (brauns a k xs)
  (ite (= xs (Nil a)) (Nil (tree a)) (let ((ys (take a (pow2 k) xs)) (zs (drop a (pow2 k) xs)))
    (let ((ts (brauns a (s k) (zs a)))) (nodes a (ts a) (ys a) (drop (tree a) (pow2 k) (ts a))))))))))
(declare-fun brauns1 (par (a) ((list a)) (tree a)))
(assert (par (a) (forall ((xs (list a))) (= (brauns1 a xs)
  (ite (= xs (Nil a)) (Leaf a) (nth (tree a) (brauns a zero xs) zero))))))
(declare-fun T_brauns (par (a) (nat (list a)) nat))
(assert (par (a) (forall ((k nat) (xs (list a))) (= (T_brauns a k xs) (ite (= xs (Nil a)) zero
  (let ((ys (take a (pow2 k) xs)) (zs (drop a (pow2 k) xs)))
    (let ((ts (brauns a (s k) (zs a)))) (plus (mult (s (s (s (s zero)))) (min (pow2 k) (len a xs)))
      (T_brauns a (s k) (zs a))))))))))
; this cannot be defined because of map and lambdas
;(declare-fun list_fast_rec (par (a) ((list (tree a))) (list a)))
;(assert (par (a) (forall ((ts )))))
(declare-fun braun_of_naive (par (a) (a nat) (tree a)))
(assert (par (a) (forall ((x a) (n nat)) (= (braun_of_naive a x n) (ite (= n zero) (Leaf a)
  (let ((m (div2 (s_0 n)))) (ite (odd n) (Node a (braun_of_naive a x m) x (braun_of_naive a x m))
    (Node a (braun_of_naive a x (s m)) x (braun_of_naive a x m)))))))))
(declare-fun nat_of ((list Bool)) nat)
(assert (= (nat_of (Nil Bool)) (s zero)))
(assert (forall ((b Bool) (bs (list Bool))) (= (nat_of (Cons Bool b bs)) (plus (mult (s (s zero)) (nat_of bs)) (ite b (s zero) zero)))))
; TODO define this
(declare-fun lookup_trie (par (a) ((tree a) (list Bool)) a))
; TODO define this
(declare-fun update_trie (par (a) ((list Bool) a (tree a)) (tree a)))

; Huffman's algorithm
(declare-fun cachedWeight (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (cachedWeight a (LeafH a w x)) w))))
(assert (par (a) (forall ((w nat) (l (treeh a)) (r (treeh a))) (= (cachedWeight a (NodeH a w l r)) w))))
(declare-fun uniteTrees (par (a) ((treeh a) (treeh a)) (treeh a)))
(assert (par (a) (forall ((t1 (treeh a)) (t2 (treeh a))) (= (uniteTrees a t1 t2)
  (NodeH a (plus (cachedWeight a t1) (cachedWeight a t2)) t1 t2)))))
(declare-fun insortTree (par (a) ((treeh a) (list (treeh a))) (list (treeh a))))
(assert (par (a) (forall ((u (treeh a))) (= (insortTree a u (Nil (treeh a))) (Cons (treeh a) u (Nil (treeh a)))))))
(assert (par (a) (forall ((u (treeh a)) (t (treeh a)) (ts (list (treeh a)))) (= (insortTree a u (Cons (treeh a) t ts))
  (ite (leq nat (cachedWeight a u) (cachedWeight a t)) (Cons (treeh a) u (Cons (treeh a) t ts))
    (Cons (treeh a) t (insortTree a u ts)))))))
(declare-fun huffman (par (a) ((list (treeh a))) (treeh a)))
(assert (par (a) (forall ((t (treeh a))) (= (huffman a (Cons (treeh a) t (Nil (treeh a)))) t))))
(assert (par (a) (forall ((t1 (treeh a)) (t2 (treeh a)) (ts (list (treeh a)))) (= (huffman a (Cons (treeh a) t1 (Cons (treeh a) t2 ts)))
  (huffman a (insortTree a (uniteTrees a t1 t2) ts))))))
(declare-fun in_alphabet (par (a) (a (treeh a)) Bool))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (in_alphabet a x (LeafH a w y)) (= x y)))))
(assert (par (a) (forall ((w nat) (x a) (t1 (treeh a)) (t2 (treeh a))) (= (in_alphabet a x (NodeH a w t1 t2))
  (or (in_alphabet a x t1) (in_alphabet a x t2))))))
(declare-fun in_alphabet_F (par (a) (a (list (treeh a))) Bool))
(assert (par (a) (forall ((x a)) (not (in_alphabet_F a x (Nil (treeh a)))))))
(assert (par (a) (forall ((x a) (t (treeh a)) (ts (list (treeh a)))) (= (in_alphabet_F a x (Cons (treeh a) t ts))
  (or (in_alphabet a x t) (in_alphabet_F a x ts))))))
(declare-fun consistent (par (a) ((treeh a)) Bool))
(assert (par (a) (forall ((w nat) (x a)) (consistent a (LeafH a w x)))))
; TODO the distinct here is not appropriate for empty intersection
;(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (consistent a (NodeH a w t1 t2))
;  (and (forall ((x a)) (distinct (in_alphabet a x t1) (in_alphabet a x t2))) (consistent a t1) (consistent a t2))))))
(declare-fun consistent_F (par (a) ((list (treeh a))) Bool))
(assert (par (a) (consistent_F a (Nil (treeh a)))))
(assert (par (a) (forall ((t (treeh a)) (ts (list (treeh a)))) (= (consistent_F a (Cons (treeh a) t ts))
  (and (consistent a t) (consistent_F a ts))))))
(declare-fun depth (par (a) ((treeh a) a) nat))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (depth a (LeafH a w x) y) zero))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a)) (x a)) (= (depth a (NodeH a w t1 t2) x)
  (ite (in_alphabet a x t1) (s (depth a t1 x)) (ite (in_alphabet a x t2) (s (depth a t2 x)) zero))))))
(declare-fun height (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (height a (LeafH a w x)) zero))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (height a (NodeH a w t1 t2))
  (s (max nat (height a t1) (height a t2)))))))
(declare-fun height_F (par (a) ((list (treeh a))) nat))
(assert (par (a) (= (height_F a (Nil (treeh a))) zero)))
(assert (par (a) (forall ((t (treeh a)) (ts (list (treeh a)))) (= (height_F a (Cons (treeh a) t ts))
  (max nat (height a t) (height_F a ts))))))
(declare-fun freq (par (a) ((treeh a) a) nat))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (freq a (LeafH a w x) y) (ite (= x y) w zero)))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a)) (x a)) (= (freq a (NodeH a w t1 t2) x)
  (plus (freq a t1 x) (freq a t2 x))))))
(declare-fun freq_F (par (a) ((list (treeh a)) a) nat))
(assert (par (a) (forall ((x a)) (= (freq_F a (Nil (treeh a)) x) zero))))
(assert (par (a) (forall ((t (treeh a)) (ts (list (treeh a))) (x a)) (= (freq_F a (Cons (treeh a) t ts) x)
  (plus (freq a t x) (freq_F a ts x))))))
(declare-fun weight (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (weight a (LeafH a w x)) w))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (weight a (NodeH a w t1 t2))
  (plus (weight a t1) (weight a t2))))))
(declare-fun cost (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (cost a (LeafH a w x)) zero))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (cost a (NodeH a w t1 t2))
  (plus (plus (weight a t1) (cost a t1)) (plus (weight a t2) (cost a t2)))))))
(declare-fun optimum (par (a) ((treeh a)) Bool))
(assert (par (a) (forall ((t (treeh a))) (= (optimum a t) (forall ((u (treeh a))) (=> (consistent a u)
  (=> (forall ((x a)) (= (in_alphabet a x t) (in_alphabet a x u))) (=> (forall ((y a)) (= (freq a u y) (freq a t y)))
    (leq nat (cost a t) (cost a u))))))))))
; TODO define this
(declare-fun swapLeaves (par (a) ((treeh a) nat a nat a) (treeh a)))
(declare-fun swapSyms (par (a) ((treeh a) a a) (treeh a)))
(assert (par (a) (forall ((t (treeh a)) (x a) (y a)) (= (swapSyms a t x y) (swapLeaves a t (freq a t x) x (freq a t y) y)))))
(declare-fun swapFourSyms (par (a) ((treeh a) a a a a) (treeh a)))
(assert (par (a) (forall ((t (treeh a)) (x a) (y a) (z a) (u a)) (= (swapFourSyms a t x y z u)
  (ite (= x u) (swapSyms a t y z) (ite (= y z) (swapSyms a t x u) (swapSyms a (swapSyms a t x z) y u)))))))
; TODO define this
(declare-fun sibling (par (a) ((treeh a) a) a))
(declare-fun mergeSibling (par (a) ((treeh a) a) (treeh a)))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (mergeSibling a (LeafH a w x) y) (LeafH a w x)))))
(assert (par (a) (forall ((w nat) (wx nat) (x a) (wy nat) (y a) (z a)) (= (mergeSibling a (NodeH a w (LeafH a wx x) (LeafH a wy y)) z)
  (ite (or (= z x) (= z y)) (LeafH a (plus wx wy) z) (NodeH a w (LeafH a wx x) (LeafH a wy y)))))))
(assert (par (a) (forall ((w nat) (v nat) (va (treeh a)) (vb (treeh a)) (t2 (treeh a)) (x a))
  (= (mergeSibling a (NodeH a w (NodeH a v va vb) t2) x) (NodeH a w (mergeSibling a (NodeH a v va vb) x) (mergeSibling a t2 x))))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (v nat) (va (treeh a)) (vb (treeh a)) (x a))
  (= (mergeSibling a (NodeH a w t1 (NodeH a v va vb)) x) (NodeH a w (mergeSibling a t1 x) (mergeSibling a (NodeH a v va vb) x))))))
(declare-fun splitLeaf (par (a) ((treeh a) nat a nat a) (treeh a)))
(assert (par (a) (forall ((wx nat) (x a) (wy nat) (y a) (wz nat) (z a)) (= (splitLeaf a (LeafH a wx x) wy y wz z)
  (ite (= x y) (NodeH a wx (LeafH a wx x) (LeafH a wz z)) (LeafH a wx x))))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a)) (wx nat) (x a) (wy nat) (y a))
  (= (splitLeaf a (NodeH a w t1 t2) wx x wy y) (NodeH a w (splitLeaf a t1 wx x wy y) (splitLeaf a t2 wx x wy y))))))
; TODO define this
(declare-fun splitLeaf_F (par (a) ((list (treeh a)) nat a nat a) (list (treeh a))))
(declare-fun minima (par (a) ((treeh a) a a) Bool))
(assert (par (a) (forall ((t (treeh a)) (x a) (y a)) (= (minima a t x y) (and (in_alphabet a x t) (in_alphabet a y t)
  (distinct x y) (forall ((z a)) (=> (in_alphabet a z t) (=> (distinct z x) (=> (distinct z y)
    (and (leq nat (freq a t x) (freq a t z)) (leq nat (freq a t y) (freq a t z))))))))))))
; TODO this definition is not fixed, so we can use the other variant with the inner forall in the recursive case
(declare-fun sortedByWeight (par (a) ((list (treeh a))) Bool))
(assert (par (a) (sortedByWeight a (Nil (treeh a)))))
(assert (par (a) (forall ((t (treeh a))) (sortedByWeight a (Cons (treeh a) t (Nil (treeh a)))))))
(assert (par (a) (forall ((t1 (treeh a)) (t2 (treeh a)) (ts (list (treeh a)))) (= (sortedByWeight a (Cons (treeh a) t1 (Cons (treeh a) t2 ts)))
  (and (leq nat (weight a t1) (weight a t2)) (sortedByWeight a (Cons (treeh a) t2 ts)))))))

; Priority queues
(declare-fun inv_heap (par (a) ((tree a)) Bool))
(assert (par (a) (inv_heap a (Leaf a))))
(assert (par (a) (forall ((l (tree a)) (m a) (r (tree a))) (= (inv_heap a (Node a l m r))
  (and (forall ((x a)) (=> (and (in_set_tree a x l) (in_set_tree a x r)) (leq a m x))) (inv_heap a l) (inv_heap a r))))))
(declare-fun heapp (par (a b) ((ptree a b)) Bool))
(assert (par (a b) (heapp a b (LeafP a b))))
(assert (par (a b) (forall ((l (ptree a b)) (m a) (n b) (r (ptree a b))) (= (heapp a b (NodeP a b l m n r))
  (and (forall ((x a)) (=> (and (in_set_ptree a b x l) (in_set_ptree a b x r)) (leq a m x))) (heapp a b l) (heapp a b r))))))
(declare-fun get_min (par (a) ((tree a)) a))
(assert (par (a) (forall ((l (tree a)) (m a) (r (tree a))) (= (get_min a (Node a l m r)) m))))
(declare-fun get_minp (par (a b) ((ptree a b)) a))
(assert (par (a b) (forall ((l (ptree a b)) (m a) (n b) (r (ptree a b))) (= (get_minp a b (NodeP a b l m n r)) m))))
(declare-fun mht (par (a) ((lheap a)) nat))
(assert (par (a) (= (mht a (LeafP a nat)) zero)))
(assert (par (a) (forall ((l (lheap a)) (m a) (n nat) (r (lheap a))) (= (mht a (NodeP a nat l m n r)) n))))
(declare-fun ltree (par (a) ((lheap a)) Bool))
(assert (par (a) (ltree a (LeafP a nat))))
; TODO in the text mh is used instead of mht here
(assert (par (a) (forall ((l (lheap a)) (m a) (n nat) (r (lheap a))) (= (ltree a (NodeP a nat l m n r))
  (and (leq nat (mht a r) (mht a l)) (= n (s (mht a r))) (ltree a l) (ltree a r))))))
(declare-fun node_lheap (par (a) ((lheap a) a (lheap a)) (lheap a)))
(assert (par (a) (forall ((l (lheap a)) (x a) (r (lheap a))) (= (node_lheap a l x r)
  (let ((mhl (mht a l)) (mhr (mht a r))) (ite (leq nat mhr mhl) (NodeP a nat l x (s mhr) r) (NodeP a nat r x (s mhl) l)))))))
(declare-fun merge_lheap (par (a) ((lheap a) (lheap a)) (lheap a)))
(assert (par (a) (forall ((t (lheap a))) (= (merge_lheap a (LeafP a nat) t) t))))
(assert (par (a) (forall ((t (lheap a))) (= (merge_lheap a t (LeafP a nat)) t))))
(assert (par (a) (forall ((l1 (lheap a)) (a1 a) (n1 nat) (r1 (lheap a)) (l2 (lheap a)) (a2 a) (n2 nat) (r2 (lheap a)))
  (= (merge_lheap a (NodeP a nat l1 a1 n1 r1) (NodeP a nat l2 a2 n2 r2))
    (ite (leq a a1 a2) (node_lheap a l1 a1 (merge_lheap a r1 (NodeP a nat l2 a2 n2 r2)))
      (node_lheap a l2 a2 (merge_lheap a (NodeP a nat l1 a1 n1 r1) r2)))))))
(declare-fun insert_lheap (par (a) (a (lheap a)) (lheap a)))
(assert (par (a) (forall ((x a) (t (lheap a))) (= (insert_lheap a x t)
  (merge_lheap a (NodeP a nat (LeafP a nat) x (s zero) (LeafP a nat)) t)))))
(declare-fun del_min_lheap (par (a) ((lheap a)) (lheap a)))
(assert (par (a) (= (del_min_lheap a (LeafP a nat)) (LeafP a nat))))
(assert (par (a) (forall ((l (lheap a)) (x a) (n nat) (r (lheap a))) (= (del_min_lheap a (NodeP a nat l x n r))
  (merge_lheap a l r)))))
(declare-fun T_merge_lheap (par (a) ((lheap a) (lheap a)) nat))
(assert (par (a) (forall ((t (lheap a))) (= (T_merge_lheap a (LeafP a nat) t) (s zero)))))
(assert (par (a) (forall ((t (lheap a))) (= (T_merge_lheap a t (LeafP a nat)) (s zero)))))
(assert (par (a) (forall ((l1 (lheap a)) (a1 a) (n1 nat) (r1 (lheap a)) (l2 (lheap a)) (a2 a) (n2 nat) (r2 (lheap a)))
  (= (T_merge_lheap a (NodeP a nat l1 a1 n1 r1) (NodeP a nat l2 a2 n2 r2))
    (s (ite (leq a a1 a2) (T_merge_lheap a r1 (NodeP a nat l2 a2 n2 r2)) (T_merge_lheap a (NodeP a nat l1 a1 n1 r1) r2)))))))
(declare-fun T_insert_lheap (par (a) (a (lheap a)) nat))
(assert (par (a) (forall ((x a) (t (lheap a))) (= (T_insert_lheap a x t)
  (s (T_merge_lheap a (NodeP a nat (LeafP a nat) x (s zero) (LeafP a nat)) t))))))
(declare-fun T_del_min_lheap (par (a) ((lheap a)) nat))
(assert (par (a) (= (T_del_min_lheap a (LeafP a nat)) (s zero))))
(assert (par (a) (forall ((l (lheap a)) (x a) (n nat) (r (lheap a)))
  (= (T_del_min_lheap a (NodeP a nat l x n r)) (s (T_merge_lheap a l r))))))

(declare-fun insert_braun (par (a) (a (tree a)) (tree a)))
(assert (par (a) (forall ((x a)) (= (insert_braun a x (Leaf a)) (Node a (Leaf a) x (Leaf a))))))
(assert (par (a) (forall ((x a) (l (tree a)) (y a) (r (tree a))) (= (insert_braun a x (Node a l y r))
  (ite (less a x y) (Node a (insert_braun a y r) x l) (Node a (insert_braun a x r) y l))))))
(declare-fun del_left (par (a) ((tree a)) (pair a (tree a))))
(assert (par (a) (forall ((x a) (r (tree a))) (= (del_left a (Node a (Leaf a) x r)) (Pair a (tree a) x r)))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (del_left a (Node a l x r))
  (let ((yl (del_left a l))) (Pair a (tree a) (Pair_0 a (tree a) (yl a)) (Node a r x (Pair_1 a (tree a) (yl a)))))))))
(declare-fun sift_down (par (a) ((tree a) a (tree a)) (tree a)))
(assert (par (a) (forall ((x a) (t (tree a))) (= (sift_down a (Leaf a) x t) (Node a (Leaf a) x (Leaf a))))))
(assert (par (a) (forall ((x a) (t (tree a)) (y a)) (= (sift_down a (Node a (Leaf a) x t) y (Leaf a))
  (ite (leq a y x) (Node a (Node a (Leaf a) x (Leaf a)) y (Leaf a)) (Node a (Node a (Leaf a) y (Leaf a)) x (Leaf a)))))))
(assert (par (a) (forall ((l1 (tree a)) (x1 a) (r1 (tree a)) (y a) (l2 (tree a)) (x2 a) (r2 (tree a)))
  (= (sift_down a (Node a l1 x1 r1) y (Node a l2 x2 r2)) (ite (and (leq a y x1) (leq a y x2))
    (Node a (Node a l1 x1 r1) y (Node a l2 x2 r2)) (ite (leq a x1 x2)
      (Node a (sift_down a l1 y r1) x1 (Node a l2 x2 r2)) (Node a (Node a l1 x1 r1) x2 (sift_down a l2 y r2))))))))
(declare-fun del_min_braun (par (a) ((tree a)) (tree a)))
(assert (par (a) (= (del_min_braun a (Leaf a)) (Leaf a))))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (del_min_braun a (Node a l x r))
  (match l (((Leaf a) (Leaf a))
            (_ (let ((yl (del_left a l))) (sift_down a r (Pair_0 a (tree a) (yl a)) (Pair_1 a (tree a) (yl a)))))))))))

; Binomial heaps

; Queues

; Splay trees
; TODO there are multiple undefined branches in splay which we cover with this uninterpreted function
(declare-const splay_undefined (par (a) (tree a)))
(declare-fun splay (par (a) (a (tree a)) (tree a)))
(assert (par (a) (forall ((x a) (AB (tree a)) (b a) (CD (tree a))) (= (splay a x (Node a AB b CD))
  (match (cmp a x b) ((LT (match AB (((Leaf a) (Node a AB b CD))
                                     ((Node a A y B') (match (cmp a x y)
                                        ((LT (ite (= A (Leaf a)) (Node a A y (Node a B' b CD))
                                            (match (splay a x A) (((Node a A1 y' A2) (Node a A1 y' (Node a A2 y (Node a B' b CD))))
                                                                  (_ (splay_undefined a))))))
                                         (EQ (Node a A y (Node a B' b CD)))
                                         (GT (ite (= B' (Leaf a)) (Node a A y (Node a B' b CD))
                                            (match (splay a x B') (((Node a B1 b' B2) (Node a (Node a A y B1) b' (Node a B2 b CD)))
                                                                  (_ (splay_undefined a))))))))))))
                      (EQ (Node a AB b CD))
                      (GT (match CD (((Leaf a) (Node a AB b CD))
                                     ((Node a C c D) (match (cmp a x c)
                                        ((LT (ite (= C (Leaf a)) (Node a (Node a AB b C) c D)
                                            (match (splay a x C) (((Node a C1 c' C2) (Node a (Node a AB b C1) c' (Node a C2 c D)))
                                                                  (_ (splay_undefined a))))))
                                         (EQ (Node a (Node a AB b C) c D))
                                         (GT (ite (= D (Leaf a)) (Node a (Node a AB b C) c D)
                                            (match (splay a x D) (((Node a D1 d D2) (Node a (Node a (Node a AB b C) c D1) d D2))
                                                                  (_ (splay_undefined a))))))))))))))))))
(declare-fun splay_max (par (a) ((tree a)) (tree a)))
(assert (par (a) (= (splay_max a (Leaf a)) (Leaf a))))
(assert (par (a) (forall ((A (tree a)) (x a)) (= (splay_max a (Node a A x (Leaf a))) (Node a A x (Leaf a))))))
(assert (par (a) (forall ((A (tree a)) (x a) (B' (tree a)) (y a) (CD (tree a))) (= (splay_max a (Node a A x (Node a B' y CD)))
  (ite (= CD (Leaf a)) (Node a (Node a A x B') y (Leaf a)) (match (splay_max a CD)
    (((Node a C z D) (Node a (Node a (Node a A x B') y C) z D))
     (_ (splay_undefined a)))))))))
(declare-fun isin_splay (par (a) ((tree a) a) Bool))
(assert (par (a) (forall ((t (tree a)) (x a)) (= (isin_splay a t x) (match (splay a x t)
  (((Leaf a) false)
   ((Node a A y B') (= x y))))))))
(declare-fun insert_splay (par (a) (a (tree a)) (tree a)))
(assert (par (a) (forall ((x a) (t (tree a))) (= (insert_splay a x t) (ite (= t (Leaf a)) (Node a (Leaf a) x (Leaf a))
  (match (splay a x t) (((Node a l y r) (match (cmp a x y) ((LT (Node a l x (Node a (Leaf a) y r)))
                                                            (EQ (Node a l y r))
                                                            (GT (Node a (Node a l y (Leaf a)) x r)))))
                        (_ (splay_undefined a)))))))))
(declare-fun delete_splay (par (a) (a (tree a)) (tree a)))
(assert (par (a) (forall ((x a) (t (tree a))) (= (delete_splay a x t) (ite (= t (Leaf a)) (Leaf a)
  (match (splay a x t) (((Node a l y r) (ite (distinct x y) (Node a l y r) (ite (= l (Leaf a)) r
    (match (splay_max a l) (((Node a l' z r') (Node a l' z r))
                            (_ (splay_undefined a))))))) (_ (splay_undefined a)))))))))


; Skew heaps
(declare-fun merge_skew (par (a) ((tree a) (tree a)) (tree a)))
(assert (par (a) (forall ((t (tree a))) (= (merge_skew a (Leaf a) t) t))))
(assert (par (a) (forall ((t (tree a))) (= (merge_skew a t (Leaf a)) t))))
(assert (par (a) (forall ((l1 (tree a)) (a1 a) (r1 (tree a)) (l2 (tree a)) (a2 a) (r2 (tree a))) (= (merge_skew a (Node a l1 a1 r1) (Node a l2 a2 r2))
  (ite (leq a a1 a2) (Node a (merge_skew a (Node a l2 a2 r2) r1) a1 l1) (Node a (merge_skew a (Node a l1 a1 r1) r2) a2 l2))))))
(declare-fun rh (par (a) ((tree a) (tree a)) nat))
(assert (par (a) (forall ((l (tree a)) (r (tree a))) (= (rh a l r) (ite (leq nat (size a l) (size a r)) (s zero) zero)))))
(declare-fun psi_skew (par (a) ((tree a)) nat))
(assert (par (a) (= (psi_skew a (Leaf a)) zero)))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (psi_skew a (Node a l x r)) (plus (plus (psi_skew a l) (psi_skew a r)) (rh a l r))))))
(declare-fun lrh (par (a) ((tree a)) nat))
(assert (par (a) (= (lrh a (Leaf a)) zero)))
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (lrh a (Node a l x r)) (plus (rh a l r) (lrh a l))))))
(declare-fun rlh (par (a) ((tree a)) nat))
(assert (par (a) (= (rlh a (Leaf a)) zero)))
; TODO this might be different than what was meant in the book because of the minus
(assert (par (a) (forall ((l (tree a)) (x a) (r (tree a))) (= (rlh a (Node a l x r)) (plus (minus (s zero) (rh a l r)) (rlh a l))))))
(declare-fun T_merge_skew (par (a) ((tree a) (tree a)) nat))
(assert (par (a) (forall ((t (tree a))) (= (T_merge_skew a (Leaf a) t) (s zero)))))
(assert (par (a) (forall ((t (tree a))) (= (T_merge_skew a t (Leaf a)) (s zero)))))
(assert (par (a) (forall ((l1 (tree a)) (a1 a) (r1 (tree a)) (l2 (tree a)) (a2 a) (r2 (tree a))) (= (T_merge_skew a (Node a l1 a1 r1) (Node a l2 a2 r2))
  (s (ite (leq a a1 a2) (T_merge_skew a (Node a l2 a2 r2) r1) (T_merge_skew a (Node a l1 a1 r1) r2)))))))



; (!xs, ys. f (xs @ ys) = f(xs) @ ys) -> mset_mset(asc x f ys) = {{x}} + mset(f([])) + mset(ys)
(parse-error)
