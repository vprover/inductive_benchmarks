; TODO try replacing this with int
(declare-datatype nat ((zero) (s (s_0 nat))))
(declare-datatype treeh (par (a) ((LeafH (LeafH_0 nat) (LeafH_1 a)) (NodeH (NodeH_0 nat) (NodeH_1 (treeh a)) (NodeH_2 (treeh a))))))
(declare-fun plus (nat nat) nat)
(assert (forall ((x nat)) (= (plus zero x) x)))
(assert (forall ((x nat) (y nat)) (= (plus (s x) y) (s (plus x y)))))
(declare-fun less (par (a) (a a) Bool))
(assert (forall ((x nat)) (not (less nat x zero))))
(assert (forall ((x nat)) (less nat zero (s x))))
(assert (forall ((x nat) (y nat)) (= (less nat (s x) (s y)) (less nat x y))))
(declare-fun leq (par (a) (a a) Bool))
(assert (par (a) (forall ((x a) (y a)) (= (less a x y) (and (leq a x y) (distinct x y))))))
(assert (par (a) (forall ((x a)) (leq a x x))))
(assert (par (a) (forall ((x a) (y a) (z a)) (=> (and (leq a x y) (leq a y z)) (leq a x z)))))
(assert (par (a) (forall ((x a) (y a)) (=> (and (leq a x y) (leq a y x)) (= x y)))))
(assert (par (a) (forall ((x a) (y a)) (or (leq a x y) (leq a y x)))))
(declare-fun max (par (a) (a a) a))
(assert (par (a) (forall ((x a) (y a)) (= (max a x y) (ite (leq a x y) y x)))))
(declare-fun in_alphabet (par (a) (a (treeh a)) Bool))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (in_alphabet a x (LeafH a w y)) (= x y)))))
(assert (par (a) (forall ((w nat) (x a) (t1 (treeh a)) (t2 (treeh a))) (= (in_alphabet a x (NodeH a w t1 t2))
  (or (in_alphabet a x t1) (in_alphabet a x t2))))))
(declare-fun consistent (par (a) ((treeh a)) Bool))
(assert (par (a) (forall ((w nat) (x a)) (consistent a (LeafH a w x)))))
; TODO the distinct here is not appropriate for empty intersection
;(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (consistent a (NodeH a w t1 t2))
;  (and (forall ((x a)) (distinct (in_alphabet a x t1) (in_alphabet a x t2))) (consistent a t1) (consistent a t2))))))
(declare-fun depth (par (a) ((treeh a) a) nat))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (depth a (LeafH a w x) y) zero))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a)) (x a)) (= (depth a (NodeH a w t1 t2) x)
  (ite (in_alphabet a x t1) (s (depth a t1 x)) (ite (in_alphabet a x t2) (s (depth a t2 x)) zero))))))
(declare-fun height (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (height a (LeafH a w x)) zero))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (height a (NodeH a w t1 t2))
  (s (max nat (height a t1) (height a t2)))))))
(declare-fun freq (par (a) ((treeh a) a) nat))
(assert (par (a) (forall ((w nat) (x a) (y a)) (= (freq a (LeafH a w x) y) (ite (= x y) w zero)))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a)) (x a)) (= (freq a (NodeH a w t1 t2) x)
  (plus (freq a t1 x) (freq a t2 x))))))
(declare-fun weight (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (weight a (LeafH a w x)) w))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (weight a (NodeH a w t1 t2))
  (plus (weight a t1) (weight a t2))))))
(declare-fun cost (par (a) ((treeh a)) nat))
(assert (par (a) (forall ((w nat) (x a)) (= (cost a (LeafH a w x)) zero))))
(assert (par (a) (forall ((w nat) (t1 (treeh a)) (t2 (treeh a))) (= (cost a (NodeH a w t1 t2))
  (plus (plus (weight a t1) (cost a t1)) (plus (weight a t2) (cost a t2)))))))
; TODO define this
(declare-fun swapLeaves (par (a) ((treeh a) nat a nat a) (treeh a)))
(declare-fun swapSyms (par (a) ((treeh a) a a) (treeh a)))
(assert (par (a) (forall ((t (treeh a)) (x a) (y a)) (= (swapSyms a t x y) (swapLeaves a t (freq a t x) x (freq a t y) y)))))
(declare-fun swapFourSyms (par (a) ((treeh a) a a a a) (treeh a)))
(assert (par (a) (forall ((t (treeh a)) (x a) (y a) (z a) (u a)) (= (swapFourSyms a t x y z u)
  (ite (= x u) (swapSyms a t y z) (ite (= y z) (swapSyms a t x u) (swapSyms a (swapSyms a t x z) y u)))))))
(declare-fun minima (par (a) ((treeh a) a a) Bool))
(assert (par (a) (forall ((t (treeh a)) (x a) (y a)) (= (minima a t x y) (and (in_alphabet a x t) (in_alphabet a y t)
  (distinct x y) (forall ((z a)) (=> (in_alphabet a z t) (=> (distinct z x) (=> (distinct z y)
    (and (leq nat (freq a t x) (freq a t z)) (leq nat (freq a t y) (freq a t z))))))))))))

; consistent t & minima t a b & c in alphabet t & d in alphabet t & depth t c = height t & depth t d = height t & c != d -> cost (swapFourSyms t a b c d) <= cost t
(assert-not (par (a) (forall ((t (treeh a)) (x a) (y a) (z a) (u a)) (=> (and (consistent a t) (minima a t x y) (in_alphabet a z t) (in_alphabet a u t)
  (= (depth a t z) (height a t)) (= (depth a t u) (height a t)) (distinct z u))
    (leq nat (cost a (swapFourSyms a t x y z u)) (cost a t))))))
